/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@wix/editor-application/dist/esm/platform-frame-api/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/dist/esm/platform-frame-api/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlatformFrameAPI: () => (/* binding */ PlatformFrameAPI)\n/* harmony export */ });\n/* harmony import */ var _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/public-editor-platform-events */ \"./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs\");\n/* harmony import */ var _wix_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wix/sdk */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/wixClient.js\");\n/* harmony import */ var _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/public-editor-platform-errors */ \"./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs\");\n\n\n\n\nclass WorkerEventsBridge {\n  constructor(platformAppEvents) {\n    this.platformAppEvents = platformAppEvents;\n  }\n  /**\n   * Notify by event from Worker Manager (platform infrastructure)\n   */\n  notify(event) {\n    switch (event.type) {\n      case _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformLifecycleEvent.EditorReady:\n        this.platformAppEvents.notify({\n          ...event,\n          // @ts-expect-error TODO: fix me\n          type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEvent.EditorReady\n        });\n        break;\n      case _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformPrivateEvent.HostEvent:\n        this.platformAppEvents.notify({\n          ...event,\n          type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEvent.HostEvent\n        });\n        break;\n    }\n  }\n  /**\n   * Subscribe to Worker (Application) event\n   */\n  subscribe(cb) {\n    this.platformAppEvents.subscribe((event) => {\n      cb(event);\n    });\n  }\n}\n\nvar PlatformConsumerEnvironmentAPIType = /* @__PURE__ */ ((PlatformConsumerEnvironmentAPIType2) => {\n  PlatformConsumerEnvironmentAPIType2[\"Frame\"] = \"PLATFORM_FRAME_API\";\n  PlatformConsumerEnvironmentAPIType2[\"Worker\"] = \"PLATFORM_WORKER_API\";\n  return PlatformConsumerEnvironmentAPIType2;\n})(PlatformConsumerEnvironmentAPIType || {});\nclass AbstractEnvironmentAPI {\n  constructor(env) {\n    this.env = env;\n    this.create();\n  }\n}\n\nvar EditorPlatformApplicationContextErrorCode = /* @__PURE__ */ ((EditorPlatformApplicationContextErrorCode2) => {\n  EditorPlatformApplicationContextErrorCode2[\"IncorrectEnvironment\"] = \"IncorrectEnvironment\";\n  EditorPlatformApplicationContextErrorCode2[\"ClientAuthError\"] = \"ClientAuthError\";\n  return EditorPlatformApplicationContextErrorCode2;\n})(EditorPlatformApplicationContextErrorCode || {});\nclass EditorPlatformApplicationContextError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_1__.BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Editor Platform Application Context Error\");\n  }\n  withUrl(url) {\n    this.state = { ...this.state, url };\n    return this;\n  }\n  withAppDefinitionId(appDefinitionId) {\n    this.state = { ...this.state, appDefinitionId };\n    return this;\n  }\n}\nconst createEditorPlatformApplicationContextError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_1__.createErrorBuilder)(EditorPlatformApplicationContextError);\nasync function transformEventPayload(eventPayload, privateAPI) {\n  if (!eventPayload?.type) {\n    return eventPayload;\n  }\n  switch (eventPayload.type) {\n    case \"componentSelectionChanged\":\n      const componentRefs = eventPayload.componentRefs || [];\n      const components = await Promise.all(\n        componentRefs.map((ref) => {\n          return privateAPI.components.getComponent(ref);\n        })\n      );\n      return {\n        type: eventPayload.type,\n        components\n      };\n    default:\n      return eventPayload;\n  }\n}\nclass ApplicationBoundEvents {\n  constructor(appDefinitionId, events, privateAPI) {\n    this.appDefinitionId = appDefinitionId;\n    this.privateAPI = privateAPI;\n    this.events = events;\n    this.subscribe = events.subscribe.bind(events);\n    this.commit = events.commit.bind(events);\n    this.startTransaction = events.startTransaction.bind(events);\n    this.silent = events.silent.bind(events);\n  }\n  events;\n  subscribe;\n  commit;\n  startTransaction;\n  silent;\n  notify(event) {\n    this.events.notify({\n      type: event.type,\n      payload: event.payload,\n      meta: {\n        appDefinitionId: this.appDefinitionId\n      }\n    });\n  }\n  notifyCustomEvent(type, payload) {\n    this.notify({\n      type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEvent.CustomEvent,\n      payload: {\n        ...payload,\n        type\n      }\n    });\n  }\n  /**\n   * TODO: we should use same interface for all events\n   * (subscribe vs addEventListener)\n   */\n  addEventListener(eventType, fn) {\n    return this.events.subscribe(async (event) => {\n      const isAppMatch = event.meta?.appDefinitionId === this.appDefinitionId || event.meta?.appDefinitionId === null;\n      const transformPayload = () => transformEventPayload(event.payload, this.privateAPI);\n      if (eventType === \"*\") {\n        fn(await transformPayload());\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEvent.CustomEvent) {\n        if (eventType === event.payload?.type && !isAppMatch) {\n          fn(await transformPayload());\n        }\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEvent.HostEvent) {\n        if (eventType === event.payload?.type && isAppMatch) {\n          fn(await transformPayload());\n        }\n      }\n    });\n  }\n}\nconst WAIT_INJECTED_TIMEOUT = 200;\nconst WAIT_INJECTED_RETRY_COUNT = 50;\nclass ContextInjectionStatus {\n  _resolveContextInjected = () => {\n  };\n  _isInjected = false;\n  key;\n  constructor(uuid) {\n    this.key = `__${uuid}_CONTEXT_INJECTION_STATUS_KEY`;\n    if (!globalThis[this.key]) {\n      globalThis[this.key] = new Promise((resolve) => {\n        this._resolveContextInjected = () => {\n          this._isInjected = true;\n          resolve();\n        };\n      });\n    }\n  }\n  isInjected() {\n    return !!this._isInjected;\n  }\n  resolveInjected() {\n    this._resolveContextInjected?.();\n  }\n  waitInjected() {\n    return new Promise((resolve, reject) => {\n      let injected = false;\n      let timeoutId;\n      let retryCount = 0;\n      const timeout = () => {\n        if (injected) {\n          return;\n        }\n        timeoutId = setTimeout(() => {\n          retryCount++;\n          if (retryCount < WAIT_INJECTED_RETRY_COUNT) {\n            if (retryCount % 10 === 0) {\n              console.log(\n                createEditorPlatformApplicationContextError(\n                  EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n                  \"contexts are not resolved, still re-trying\"\n                ).withMessage(`try number ${retryCount}`).message\n              );\n            }\n            timeout();\n            return;\n          }\n          if (!injected) {\n            const error = createEditorPlatformApplicationContextError(\n              EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n              \"contexts are not resolved, threw by timeout\"\n            );\n            reject(error);\n          }\n        }, WAIT_INJECTED_TIMEOUT);\n      };\n      timeout();\n      const _waitContextInjectedPromise = globalThis[this.key];\n      _waitContextInjectedPromise.then(() => {\n        injected = true;\n        clearTimeout(timeoutId);\n        resolve();\n      });\n    });\n  }\n}\nconst ENVIRONMENT_CONTEXT_KEY = \"__ENVIRONMENT_CONTEXT_KEY\";\nvar PlatformEnvironment = /* @__PURE__ */ ((PlatformEnvironment2) => {\n  PlatformEnvironment2[\"Worker\"] = \"Worker\";\n  PlatformEnvironment2[\"Frame\"] = \"Frame\";\n  PlatformEnvironment2[\"ComponentPanel\"] = \"ComponentPanel\";\n  return PlatformEnvironment2;\n})(PlatformEnvironment || {});\nclass EnvironmentContext {\n  constructor(environmentContext) {\n    this.environmentContext = environmentContext;\n  }\n  static status = new ContextInjectionStatus(\"environment\");\n  static async inject(context) {\n    if (globalThis[ENVIRONMENT_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Environment context already exists and should not be overridden\"\n      );\n    }\n    globalThis[ENVIRONMENT_CONTEXT_KEY] = new EnvironmentContext(context);\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    await this.status.waitInjected();\n    return globalThis[ENVIRONMENT_CONTEXT_KEY];\n  }\n  getPrivateAPI() {\n    return this.environmentContext.privateApi;\n  }\n  getEvents() {\n    return this.environmentContext.events;\n  }\n  getApplicationAPIs() {\n    return this.environmentContext.applicationAPIs ?? {};\n  }\n  getEnvironment() {\n    return this.environmentContext.environment;\n  }\n}\nconst APPLICATION_CONTEXT_KEY = \"__APPLICATION_CONTEXT_KEY\";\nclass ApplicationContext {\n  constructor(applicationContext, environment) {\n    this.applicationContext = applicationContext;\n    this.environment = environment;\n    this.events = new ApplicationBoundEvents(\n      this.applicationContext.appDefinitionId,\n      this.environment.getEvents(),\n      this.environment.getPrivateAPI()\n    );\n  }\n  static status = new ContextInjectionStatus(\"application\");\n  /**\n   * TODO: use generics for context type\n   * - application\n   * - editor\n   */\n  static async inject(context) {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() !== PlatformEnvironment.Frame) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context can be injected only in frame environment\"\n      );\n    }\n    if (globalThis[APPLICATION_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context already exists and should not be overridden\"\n      );\n    }\n    globalThis[APPLICATION_CONTEXT_KEY] = new ApplicationContext(\n      context,\n      await EnvironmentContext.getInstance()\n    );\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() === PlatformEnvironment.Frame) {\n      await this.status.waitInjected();\n      return globalThis[APPLICATION_CONTEXT_KEY];\n    } else {\n      return __APPLICATION_CONTEXT_KEY;\n    }\n  }\n  events;\n  getAppDefinitionId() {\n    return this.applicationContext.appDefinitionId;\n  }\n  getBindings() {\n    return this.applicationContext;\n  }\n  getEvents() {\n    return this.events;\n  }\n  getPrivateAPI() {\n    return this.environment.getPrivateAPI();\n  }\n  getPrivateApplicationAPI() {\n    const appDefinitionId = this.getAppDefinitionId();\n    if (!appDefinitionId) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"appDefinitionId is not available\"\n      );\n    }\n    return this.environment.getApplicationAPIs()[appDefinitionId];\n  }\n}\nconst createSDKHost = (props) => {\n  const environmentContext = new EnvironmentContext({\n    environment: props.environment,\n    privateApi: props.privateAPI,\n    events: props.events ?? new _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEventEmitter(),\n    applicationAPIs: props.applicationPrivateAPI ? {\n      [props.appDefinitionId]: props.applicationPrivateAPI\n    } : {}\n  });\n  const applicationContext = new ApplicationContext(\n    {\n      appDefinitionId: props.appDefinitionId,\n      appDefinitionName: \"\"\n    },\n    environmentContext\n  );\n  return {\n    environment: {},\n    channel: {\n      observeState: async () => {\n        return {\n          disconnect() {\n          }\n        };\n      }\n    },\n    environmentContext,\n    applicationContext\n  };\n};\nconst auth = (appDefinitionId, privateAPI) => {\n  return {\n    getAuthHeaders: async () => {\n      if (!appDefinitionId) {\n        throw createEditorPlatformApplicationContextError(\n          EditorPlatformApplicationContextErrorCode.ClientAuthError\n        );\n      }\n      const authInstance = await privateAPI.info.getAppInstance(appDefinitionId);\n      if (authInstance === void 0) {\n        throw createEditorPlatformApplicationContextError(\n          EditorPlatformApplicationContextErrorCode.ClientAuthError,\n          \"empty auth instance\"\n        ).withAppDefinitionId(appDefinitionId);\n      }\n      return {\n        headers: {\n          Authorization: authInstance\n        }\n      };\n    }\n  };\n};\n\nconst DESIGN_SYSTEM_STYLES_MAP = {\n  classic: \"https://www.unpkg.com/@wix/design-system/dist/statics/tokens-default.global.css\",\n  studio: \"https://www.unpkg.com/@wix/design-system/dist/statics/tokens-studio.global.css\"\n};\nclass PlatformFrameAPI extends AbstractEnvironmentAPI {\n  type = PlatformConsumerEnvironmentAPIType.Frame;\n  #events = new _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_0__.PlatformAppEventEmitter();\n  #eventsBridge = new WorkerEventsBridge(this.#events);\n  #privateAPI;\n  #applicationPrivateAPI;\n  constructor() {\n    super(PlatformConsumerEnvironmentAPIType.Frame);\n  }\n  create() {\n    if (typeof globalThis?.document?.head?.prepend === \"function\") {\n      const params = new URL(globalThis.location.href).searchParams;\n      const host = params.get(\"editorType\") === \"CLASSIC\" ? \"classic\" : \"studio\";\n      const url = DESIGN_SYSTEM_STYLES_MAP[host];\n      const isAlreadyLoaded = url && !!document.querySelectorAll(`link[type=\"text/css\"][href=\"${url}\"]`)?.length;\n      if (url && !isAlreadyLoaded) {\n        const link = document.createElement(\"link\");\n        link.setAttribute(\"rel\", \"stylesheet\");\n        link.setAttribute(\"type\", \"text/css\");\n        link.setAttribute(\"href\", url);\n        globalThis.document.head.prepend(link);\n      }\n    }\n  }\n  async initEnvironment(props) {\n    const { applicationPrivateAPI, privateAPI, appDefinitionId } = props;\n    this.#applicationPrivateAPI = applicationPrivateAPI;\n    this.#privateAPI = privateAPI;\n    await EnvironmentContext.inject({\n      environment: PlatformEnvironment.Frame,\n      privateApi: privateAPI,\n      events: this.#events,\n      applicationAPIs: {\n        [appDefinitionId]: this.#applicationPrivateAPI\n      }\n    });\n    await ApplicationContext.inject({\n      appDefinitionId,\n      appDefinitionName: \"\"\n    });\n    const client = (0,_wix_sdk__WEBPACK_IMPORTED_MODULE_2__.createClient)({\n      auth: auth(appDefinitionId, privateAPI),\n      host: createSDKHost({\n        appDefinitionId,\n        privateAPI: this.#privateAPI,\n        environment: PlatformEnvironment.Frame,\n        events: this.#events,\n        applicationPrivateAPI: this.#applicationPrivateAPI\n      })\n    });\n    client.enableContext(\"global\");\n  }\n  notify(event) {\n    this.#eventsBridge.notify(event);\n  }\n  subscribe(cb) {\n    this.#eventsBridge.subscribe(cb);\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/dist/esm/platform-frame-api/index.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/dist/esm/platform-worker-api/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/dist/esm/platform-worker-api/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlatformWorkerAPI: () => (/* binding */ PlatformWorkerAPI)\n/* harmony export */ });\n/* harmony import */ var _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/public-editor-platform-events */ \"./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs\");\n/* harmony import */ var _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wix/public-editor-platform-errors */ \"./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs\");\n/* harmony import */ var _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/public-editor-platform-interfaces */ \"./node_modules/@wix/public-editor-platform-interfaces/dist/index.js\");\n/* harmony import */ var _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _wix_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wix/sdk */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/wixClient.js\");\n\n\n\n\n\nclass WorkerEventsBridge {\n  constructor(platformAppEvents) {\n    this.platformAppEvents = platformAppEvents;\n  }\n  /**\n   * Notify by event from Worker Manager (platform infrastructure)\n   */\n  notify(event) {\n    switch (event.type) {\n      case _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformLifecycleEvent.EditorReady:\n        this.platformAppEvents.notify({\n          ...event,\n          // @ts-expect-error TODO: fix me\n          type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.EditorReady\n        });\n        break;\n      case _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformPrivateEvent.HostEvent:\n        this.platformAppEvents.notify({\n          ...event,\n          type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.HostEvent\n        });\n        break;\n    }\n  }\n  /**\n   * Subscribe to Worker (Application) event\n   */\n  subscribe(cb) {\n    this.platformAppEvents.subscribe((event) => {\n      cb(event);\n    });\n  }\n}\n\nvar EditorPlatformApplicationContextErrorCode = /* @__PURE__ */ ((EditorPlatformApplicationContextErrorCode2) => {\n  EditorPlatformApplicationContextErrorCode2[\"IncorrectEnvironment\"] = \"IncorrectEnvironment\";\n  EditorPlatformApplicationContextErrorCode2[\"ClientAuthError\"] = \"ClientAuthError\";\n  return EditorPlatformApplicationContextErrorCode2;\n})(EditorPlatformApplicationContextErrorCode || {});\nclass EditorPlatformApplicationContextError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Editor Platform Application Context Error\");\n  }\n  withUrl(url) {\n    this.state = { ...this.state, url };\n    return this;\n  }\n  withAppDefinitionId(appDefinitionId) {\n    this.state = { ...this.state, appDefinitionId };\n    return this;\n  }\n}\nconst createEditorPlatformApplicationContextError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.createErrorBuilder)(EditorPlatformApplicationContextError);\nasync function transformEventPayload(eventPayload, privateAPI) {\n  if (!eventPayload?.type) {\n    return eventPayload;\n  }\n  switch (eventPayload.type) {\n    case \"componentSelectionChanged\":\n      const componentRefs = eventPayload.componentRefs || [];\n      const components = await Promise.all(\n        componentRefs.map((ref) => {\n          return privateAPI.components.getComponent(ref);\n        })\n      );\n      return {\n        type: eventPayload.type,\n        components\n      };\n    default:\n      return eventPayload;\n  }\n}\nclass ApplicationBoundEvents {\n  constructor(appDefinitionId, events, privateAPI) {\n    this.appDefinitionId = appDefinitionId;\n    this.privateAPI = privateAPI;\n    this.events = events;\n    this.subscribe = events.subscribe.bind(events);\n    this.commit = events.commit.bind(events);\n    this.startTransaction = events.startTransaction.bind(events);\n    this.silent = events.silent.bind(events);\n  }\n  events;\n  subscribe;\n  commit;\n  startTransaction;\n  silent;\n  notify(event) {\n    this.events.notify({\n      type: event.type,\n      payload: event.payload,\n      meta: {\n        appDefinitionId: this.appDefinitionId\n      }\n    });\n  }\n  notifyCustomEvent(type, payload) {\n    this.notify({\n      type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.CustomEvent,\n      payload: {\n        ...payload,\n        type\n      }\n    });\n  }\n  /**\n   * TODO: we should use same interface for all events\n   * (subscribe vs addEventListener)\n   */\n  addEventListener(eventType, fn) {\n    return this.events.subscribe(async (event) => {\n      const isAppMatch = event.meta?.appDefinitionId === this.appDefinitionId || event.meta?.appDefinitionId === null;\n      const transformPayload = () => transformEventPayload(event.payload, this.privateAPI);\n      if (eventType === \"*\") {\n        fn(await transformPayload());\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.CustomEvent) {\n        if (eventType === event.payload?.type && !isAppMatch) {\n          fn(await transformPayload());\n        }\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.HostEvent) {\n        if (eventType === event.payload?.type && isAppMatch) {\n          fn(await transformPayload());\n        }\n      }\n    });\n  }\n}\nconst WAIT_INJECTED_TIMEOUT = 200;\nconst WAIT_INJECTED_RETRY_COUNT = 50;\nclass ContextInjectionStatus {\n  _resolveContextInjected = () => {\n  };\n  _isInjected = false;\n  key;\n  constructor(uuid) {\n    this.key = `__${uuid}_CONTEXT_INJECTION_STATUS_KEY`;\n    if (!globalThis[this.key]) {\n      globalThis[this.key] = new Promise((resolve) => {\n        this._resolveContextInjected = () => {\n          this._isInjected = true;\n          resolve();\n        };\n      });\n    }\n  }\n  isInjected() {\n    return !!this._isInjected;\n  }\n  resolveInjected() {\n    this._resolveContextInjected?.();\n  }\n  waitInjected() {\n    return new Promise((resolve, reject) => {\n      let injected = false;\n      let timeoutId;\n      let retryCount = 0;\n      const timeout = () => {\n        if (injected) {\n          return;\n        }\n        timeoutId = setTimeout(() => {\n          retryCount++;\n          if (retryCount < WAIT_INJECTED_RETRY_COUNT) {\n            if (retryCount % 10 === 0) {\n              console.log(\n                createEditorPlatformApplicationContextError(\n                  EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n                  \"contexts are not resolved, still re-trying\"\n                ).withMessage(`try number ${retryCount}`).message\n              );\n            }\n            timeout();\n            return;\n          }\n          if (!injected) {\n            const error = createEditorPlatformApplicationContextError(\n              EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n              \"contexts are not resolved, threw by timeout\"\n            );\n            reject(error);\n          }\n        }, WAIT_INJECTED_TIMEOUT);\n      };\n      timeout();\n      const _waitContextInjectedPromise = globalThis[this.key];\n      _waitContextInjectedPromise.then(() => {\n        injected = true;\n        clearTimeout(timeoutId);\n        resolve();\n      });\n    });\n  }\n}\nconst ENVIRONMENT_CONTEXT_KEY = \"__ENVIRONMENT_CONTEXT_KEY\";\nvar PlatformEnvironment = /* @__PURE__ */ ((PlatformEnvironment2) => {\n  PlatformEnvironment2[\"Worker\"] = \"Worker\";\n  PlatformEnvironment2[\"Frame\"] = \"Frame\";\n  PlatformEnvironment2[\"ComponentPanel\"] = \"ComponentPanel\";\n  return PlatformEnvironment2;\n})(PlatformEnvironment || {});\nclass EnvironmentContext {\n  constructor(environmentContext) {\n    this.environmentContext = environmentContext;\n  }\n  static status = new ContextInjectionStatus(\"environment\");\n  static async inject(context) {\n    if (globalThis[ENVIRONMENT_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Environment context already exists and should not be overridden\"\n      );\n    }\n    globalThis[ENVIRONMENT_CONTEXT_KEY] = new EnvironmentContext(context);\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    await this.status.waitInjected();\n    return globalThis[ENVIRONMENT_CONTEXT_KEY];\n  }\n  getPrivateAPI() {\n    return this.environmentContext.privateApi;\n  }\n  getEvents() {\n    return this.environmentContext.events;\n  }\n  getApplicationAPIs() {\n    return this.environmentContext.applicationAPIs ?? {};\n  }\n  getEnvironment() {\n    return this.environmentContext.environment;\n  }\n}\nconst APPLICATION_CONTEXT_KEY = \"__APPLICATION_CONTEXT_KEY\";\nclass ApplicationContext {\n  constructor(applicationContext, environment) {\n    this.applicationContext = applicationContext;\n    this.environment = environment;\n    this.events = new ApplicationBoundEvents(\n      this.applicationContext.appDefinitionId,\n      this.environment.getEvents(),\n      this.environment.getPrivateAPI()\n    );\n  }\n  static status = new ContextInjectionStatus(\"application\");\n  /**\n   * TODO: use generics for context type\n   * - application\n   * - editor\n   */\n  static async inject(context) {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() !== PlatformEnvironment.Frame) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context can be injected only in frame environment\"\n      );\n    }\n    if (globalThis[APPLICATION_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context already exists and should not be overridden\"\n      );\n    }\n    globalThis[APPLICATION_CONTEXT_KEY] = new ApplicationContext(\n      context,\n      await EnvironmentContext.getInstance()\n    );\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() === PlatformEnvironment.Frame) {\n      await this.status.waitInjected();\n      return globalThis[APPLICATION_CONTEXT_KEY];\n    } else {\n      return __APPLICATION_CONTEXT_KEY;\n    }\n  }\n  events;\n  getAppDefinitionId() {\n    return this.applicationContext.appDefinitionId;\n  }\n  getBindings() {\n    return this.applicationContext;\n  }\n  getEvents() {\n    return this.events;\n  }\n  getPrivateAPI() {\n    return this.environment.getPrivateAPI();\n  }\n  getPrivateApplicationAPI() {\n    const appDefinitionId = this.getAppDefinitionId();\n    if (!appDefinitionId) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"appDefinitionId is not available\"\n      );\n    }\n    return this.environment.getApplicationAPIs()[appDefinitionId];\n  }\n}\nconst createSDKHost = (props) => {\n  const environmentContext = new EnvironmentContext({\n    environment: props.environment,\n    privateApi: props.privateAPI,\n    events: props.events ?? new _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEventEmitter(),\n    applicationAPIs: props.applicationPrivateAPI ? {\n      [props.appDefinitionId]: props.applicationPrivateAPI\n    } : {}\n  });\n  const applicationContext = new ApplicationContext(\n    {\n      appDefinitionId: props.appDefinitionId,\n      appDefinitionName: \"\"\n    },\n    environmentContext\n  );\n  return {\n    environment: {},\n    channel: {\n      observeState: async () => {\n        return {\n          disconnect() {\n          }\n        };\n      }\n    },\n    environmentContext,\n    applicationContext\n  };\n};\nconst auth = (appDefinitionId, privateAPI) => {\n  return {\n    getAuthHeaders: async () => {\n      if (!appDefinitionId) {\n        throw createEditorPlatformApplicationContextError(\n          EditorPlatformApplicationContextErrorCode.ClientAuthError\n        );\n      }\n      const authInstance = await privateAPI.info.getAppInstance(appDefinitionId);\n      if (authInstance === void 0) {\n        throw createEditorPlatformApplicationContextError(\n          EditorPlatformApplicationContextErrorCode.ClientAuthError,\n          \"empty auth instance\"\n        ).withAppDefinitionId(appDefinitionId);\n      }\n      return {\n        headers: {\n          Authorization: authInstance\n        }\n      };\n    }\n  };\n};\n\nvar EditorPlatformApplicationErrorCode = /* @__PURE__ */ ((EditorPlatformApplicationErrorCode2) => {\n  EditorPlatformApplicationErrorCode2[\"ApplicationRuntimeError\"] = \"ApplicationRuntimeError\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationCreationError\"] = \"ApplicationCreationError\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationLoadError\"] = \"ApplicationLoadError\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationFetchError\"] = \"ApplicationFetchError\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationExecuteError\"] = \"ApplicationExecuteError\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationWasRemoved\"] = \"ApplicationWasRemoved\";\n  EditorPlatformApplicationErrorCode2[\"UndefinedApiMethod\"] = \"UndefinedApiMethod\";\n  EditorPlatformApplicationErrorCode2[\"ApplicationIsNotMutable\"] = \"ApplicationIsNotMutable\";\n  EditorPlatformApplicationErrorCode2[\"FailedToGetPrivateAPI\"] = \"FailedToGetPrivateAPI\";\n  EditorPlatformApplicationErrorCode2[\"ClientAuthError\"] = \"ClientAuthError\";\n  return EditorPlatformApplicationErrorCode2;\n})(EditorPlatformApplicationErrorCode || {});\nclass EditorPlatformApplicationError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Editor Platform Application Error\");\n  }\n  withUrl(url) {\n    this.state = { ...this.state, url };\n    return this;\n  }\n  withAppDefinitionId(appDefinitionId) {\n    this.state = { ...this.state, appDefinitionId };\n    return this;\n  }\n  withApiMethod(apiMethod) {\n    this.state = { ...this.state, apiMethod };\n    return this;\n  }\n  withApiType(apiType) {\n    this.state = { ...this.state, apiType };\n    return this;\n  }\n}\nconst createEditorPlatformApplicationError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.createErrorBuilder)(EditorPlatformApplicationError);\n\nconst APPLICATION_REGISTRY_KEY = \"__APPLICATION_REGISTRY_KEY\";\nasync function executeApplication(events, client, spec, bundle) {\n  const executable = new Function(\n    \"$wixContext\",\n    APPLICATION_CONTEXT_KEY,\n    APPLICATION_REGISTRY_KEY,\n    bundle\n  );\n  let instance;\n  const applicationRegistryCallback = (_instance) => {\n    if (instance) {\n      throw createEditorPlatformApplicationError(\n        EditorPlatformApplicationErrorCode.ApplicationExecuteError,\n        \"Application registry called more than once\"\n      ).withAppDefinitionId(spec.appDefinitionId);\n    }\n    if (_instance.type !== spec.type) {\n      throw createEditorPlatformApplicationError(\n        EditorPlatformApplicationErrorCode.ApplicationExecuteError,\n        \"Application has different type\"\n      ).withMessage(\"expected type\", spec.type).withMessage(\"received type\", _instance.type);\n    }\n    instance = _instance;\n  };\n  try {\n    const context = { ...spec };\n    executable.call(\n      { client },\n      new ApplicationContext(context, await EnvironmentContext.getInstance()),\n      applicationRegistryCallback\n    );\n  } catch (e) {\n    throw createEditorPlatformApplicationError(\n      EditorPlatformApplicationErrorCode.ApplicationExecuteError,\n      e.message\n    ).withAppDefinitionId(spec.appDefinitionId).withParentError(e);\n  }\n  return new Promise((resolve, reject) => {\n    const unsubscribe = events.subscribe((event) => {\n      const timeoutId = setTimeout(() => {\n        clearTimeout(timeoutId);\n        unsubscribe();\n        if (!instance) {\n          reject(\n            createEditorPlatformApplicationError(\n              EditorPlatformApplicationErrorCode.ApplicationExecuteError,\n              \"Application registry was not called, threw by timeout\"\n            ).withAppDefinitionId(spec.appDefinitionId)\n          );\n        }\n      }, 5e3);\n      if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.ApplicationInit && event.meta.appDefinitionId === spec.appDefinitionId) {\n        clearTimeout(timeoutId);\n        unsubscribe();\n        if (!instance) {\n          reject(\n            createEditorPlatformApplicationError(\n              EditorPlatformApplicationErrorCode.ApplicationExecuteError,\n              \"Application registry was not called\"\n            ).withAppDefinitionId(spec.appDefinitionId)\n          );\n        }\n        resolve({ instance });\n      }\n    });\n  });\n}\n\nclass PlatformApplicationContainer {\n  #apps = {};\n  #privateAPI;\n  #events;\n  constructor(privateApi, events) {\n    this.#privateAPI = privateApi;\n    this.#events = events;\n    this.#events.subscribe((event) => {\n      switch (event.type) {\n        case _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEvent.HostEvent: {\n          if (event.payload.type === _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__.EventType.removeAppCompleted) {\n            void this.#events.withEvent(\n              this.#events.factories.createApplicationRemovedEvent(\n                event.payload.appDefinitionId\n              ),\n              () => {\n                return this.removeApplication(event.payload.appDefinitionId);\n              }\n            );\n          }\n          break;\n        }\n      }\n    });\n  }\n  async runApplication(app) {\n    const bundle = await this.loadApplication(app);\n    const instance = await this.executeApplication(app, bundle);\n    this.setApplication(app.appDefinitionId, instance);\n    return instance;\n  }\n  setApplication(appDefId, instance) {\n    this.#apps[appDefId] = instance;\n    void this.#events.withEvent(\n      this.#events.factories.createApplicationApiInitEvent(\n        appDefId,\n        // TODO: both types are set here...\n        // @ts-expect-error TODO: fix me\n        instance?.api?.private ? \"private\" : \"public\"\n      ),\n      () => {\n        this.#privateAPI.applicationManager.setApplication(instance);\n      }\n    );\n  }\n  getApplication(appDefId) {\n    return this.#apps[appDefId];\n  }\n  getAppDefinitionIds() {\n    return Object.keys(this.#apps);\n  }\n  removeApplication(appDefinitionId) {\n    delete this.#apps[appDefinitionId];\n  }\n  async loadApplication(app) {\n    const url = app.url;\n    return this.#events.withEvent(\n      this.#events.factories.createApplicationLoadEvent(app, url),\n      async () => {\n        try {\n          return await this.loadApplicationBundle(url);\n        } catch (e) {\n          throw createEditorPlatformApplicationError(\n            EditorPlatformApplicationErrorCode.ApplicationLoadError\n          ).withUrl(url).withAppDefinitionId(app.appDefinitionId).withParentError(e);\n        }\n      }\n    );\n  }\n  async loadApplicationBundle(url) {\n    const res = await fetch(\"url\", {\n      method: \"GET\"\n    });\n    const isSuccessfulResponse = res.status >= 200 && res.status <= 299;\n    if (!isSuccessfulResponse) {\n      throw createEditorPlatformApplicationError(\n        EditorPlatformApplicationErrorCode.ApplicationFetchError\n      ).withUrl(url);\n    }\n    return res.text();\n  }\n  async executeApplication(app, bundle) {\n    return this.#events.withEvent(\n      this.#events.factories.createApplicationExecuteEvent(app, app.url),\n      async () => {\n        const client = this.#createWixClient(app.appDefinitionId);\n        const { instance } = await executeApplication(\n          this.#events,\n          client,\n          app,\n          bundle\n        );\n        return instance;\n      }\n    );\n  }\n  #createWixClient(appDefinitionId) {\n    return (0,_wix_sdk__WEBPACK_IMPORTED_MODULE_3__.createClient)({\n      auth: auth(appDefinitionId, this.#privateAPI),\n      host: createSDKHost({\n        appDefinitionId,\n        privateAPI: this.#privateAPI,\n        environment: PlatformEnvironment.Worker,\n        events: this.#events,\n        applicationPrivateAPI: {}\n      })\n    });\n  }\n}\n\nvar PlatformConsumerEnvironmentAPIType = /* @__PURE__ */ ((PlatformConsumerEnvironmentAPIType2) => {\n  PlatformConsumerEnvironmentAPIType2[\"Frame\"] = \"PLATFORM_FRAME_API\";\n  PlatformConsumerEnvironmentAPIType2[\"Worker\"] = \"PLATFORM_WORKER_API\";\n  return PlatformConsumerEnvironmentAPIType2;\n})(PlatformConsumerEnvironmentAPIType || {});\nclass AbstractEnvironmentAPI {\n  constructor(env) {\n    this.env = env;\n    this.create();\n  }\n}\n\nclass PlatformWorkerAPI extends AbstractEnvironmentAPI {\n  type = PlatformConsumerEnvironmentAPIType.Worker;\n  #events = new _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_1__.PlatformAppEventEmitter();\n  #eventsBridge = new WorkerEventsBridge(this.#events);\n  #container = null;\n  #privateAPI;\n  #pendingWaiters = [];\n  constructor() {\n    super(PlatformConsumerEnvironmentAPIType.Worker);\n  }\n  create() {\n  }\n  async initEnvironment(props) {\n    const { buildPrivateAPI } = props;\n    this.#privateAPI = await buildPrivateAPI({\n      // TODO: should be per application (within the container before app execution)\n      type: \"EDITOR_ADDON\"\n    });\n    await EnvironmentContext.inject({\n      environment: PlatformEnvironment.Worker,\n      events: this.#events,\n      privateApi: this.#privateAPI,\n      applicationAPIs: {}\n    });\n    this.#container = new PlatformApplicationContainer(\n      this.#privateAPI,\n      this.#events\n    );\n    this.#pendingWaiters.forEach((res) => res(this));\n  }\n  async notify(event) {\n    await this.waitReady();\n    this.#eventsBridge.notify(event);\n  }\n  subscribe(cb) {\n    this.#eventsBridge.subscribe(cb);\n  }\n  async runApplication(app) {\n    await this.waitReady();\n    await this.#container.runApplication(app);\n  }\n  waitReady() {\n    return new Promise((res) => {\n      if (this.#privateAPI) {\n        return res(this);\n      }\n      this.#pendingWaiters.push(res);\n    });\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/dist/esm/platform-worker-api/index.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-platform-transport/dist/esm/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@wix/editor-platform-transport/dist/esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsumerChannel: () => (/* binding */ ConsumerChannel),\n/* harmony export */   HostChannel: () => (/* binding */ HostChannel),\n/* harmony export */   IFrameConsumerChannel: () => (/* binding */ IFrameConsumerChannel),\n/* harmony export */   IFrameHostChannel: () => (/* binding */ IFrameHostChannel),\n/* harmony export */   WorkerConsumerChannel: () => (/* binding */ WorkerConsumerChannel),\n/* harmony export */   WorkerHostChannel: () => (/* binding */ WorkerHostChannel)\n/* harmony export */ });\nconst errorMessage = (message) => {\n  return `\"editor-platform-transport\": ${message}`;\n};\nconst internalErrorMessage = (message) => {\n  return errorMessage(`[Internal Error] ${message}`);\n};\n\nconst FUNCTION_MARKER = \"\\u0192\";\nconst ACCESSOR_MARKER = \"\\u2202\";\nconst ACCESSOR_GET_POINTER = \"_get_\";\nconst ACCESSOR_SET_POINTER = \"_set_\";\nconst WITH_ACCESSOR_INDICATOR = \"+\";\nconst NO_ACCESSOR_INDICATOR = \"-\";\nconst PATH_SEPARATOR = \"\\xB7\";\nconst ENCODER_MARKER = \"\\xD7\";\nconst ENCODER_EMPTY_MARKER = \"\\xB0\";\nconst extractPointer = (pointer) => pointer[0] === ENCODER_MARKER ? \"\" : pointer;\nconst isFinalNode = (instance) => {\n  return instance === null || typeof instance === \"undefined\" || typeof instance === \"symbol\" || typeof instance === \"number\" || typeof instance === \"boolean\" || typeof instance === \"function\" || typeof instance === \"string\";\n};\nconst isSerializableType = (instance) => {\n  return !!instance && typeof instance === \"object\" && !Array.isArray(instance) && !(instance instanceof Date) && !(instance instanceof Set) && !(instance instanceof Map);\n};\nconst beautifyPath = (path) => beautifyBreadcrumbs(path.split(PATH_SEPARATOR));\nconst beautifyBreadcrumbs = (breadcrumbs) => breadcrumbs.map(extractPointer).filter(Boolean).join(\".\");\n\nfunction createStructureEncoder(marker, config) {\n  return {\n    marker,\n    ...config\n  };\n}\nconst arrayEncoder = createStructureEncoder(\"A\", {\n  shouldUse: (instance) => Array.isArray(instance),\n  serialize: (instance, next) => {\n    if (!instance.length) {\n      next(\"\", ENCODER_EMPTY_MARKER);\n    } else {\n      instance.forEach((value, index) => {\n        next(`${index}`, value);\n      });\n    }\n  },\n  deserialize: {\n    create: () => [],\n    has: (instance, key) => !(typeof instance[key] === \"undefined\"),\n    append: (instance, _key, value) => {\n      instance.push(value);\n    }\n  }\n});\nconst mapEncoder = createStructureEncoder(\"M\", {\n  shouldUse: (instance) => instance instanceof Map,\n  serialize: (instance, next) => {\n    instance.forEach((value, key) => {\n      next(key, value);\n    });\n  },\n  deserialize: {\n    create: () => /* @__PURE__ */ new Map(),\n    has: (instance, key) => instance.has(key),\n    append: (instance, key, value) => {\n      instance.set(key, value);\n    }\n  }\n});\nconst setEncoder = createStructureEncoder(\"S\", {\n  shouldUse: (instance) => instance instanceof Set,\n  serialize: (instance, next) => {\n    let index = 0;\n    instance.forEach((value) => {\n      next(`${index++}`, value);\n    });\n  },\n  deserialize: {\n    create: () => /* @__PURE__ */ new Set(),\n    has: (instance, key) => instance.has(key),\n    append: (instance, _key, value) => {\n      instance.add(value);\n    }\n  }\n});\nconst objectEncoder = createStructureEncoder(\n  \"O\",\n  {\n    shouldUse: (instance) => typeof instance === \"object\",\n    serialize: (root, next) => {\n      const forEachMember = (instance) => {\n        const keys = Reflect.ownKeys(instance);\n        const members = keys.filter((key) => {\n          return key !== \"constructor\";\n        }).filter((key) => {\n          return typeof key !== \"symbol\";\n        });\n        if (!members.length) {\n          next(\"\", ENCODER_EMPTY_MARKER);\n        } else {\n          members.filter((key) => {\n            return key !== \"constructor\";\n          }).filter((key) => {\n            return typeof key !== \"symbol\";\n          }).forEach((key) => {\n            const value = Reflect.get(root, key);\n            next(key, value);\n          });\n        }\n        const parent = Reflect.getPrototypeOf(instance);\n        if (!parent || parent?.hasOwnProperty(\"__proto__\")) {\n          return;\n        }\n        forEachMember(parent);\n      };\n      forEachMember(root);\n    },\n    deserialize: {\n      create: () => ({}),\n      has: (instance, key) => !!instance[key],\n      append: (instance, key, value) => {\n        instance[key] = value;\n      }\n    }\n  }\n);\n\nconst encoders = [arrayEncoder, setEncoder, mapEncoder];\nfunction getDescriptor(obj, key) {\n  let _instance = obj;\n  while (_instance) {\n    const descriptor = Object.getOwnPropertyDescriptor(_instance, key);\n    if (descriptor) {\n      return descriptor;\n    }\n    _instance = Reflect.getPrototypeOf(_instance);\n  }\n  return null;\n}\nfunction forEachMember(root, callback) {\n  const ancestors = /* @__PURE__ */ new WeakMap();\n  const getContextPointer = (breadcrumbs) => {\n    const _breadcrumbs = breadcrumbs.slice(1).map(extractPointer).filter(Boolean);\n    return _breadcrumbs.slice(1).reduce(\n      (acc, pointer) => {\n        return {\n          context: acc.context[acc.pointer],\n          pointer\n        };\n      },\n      {\n        context: root,\n        pointer: _breadcrumbs[0]\n      }\n    );\n  };\n  const iterateStructure = (instance, breadcrumbs = []) => {\n    if (ancestors.has(instance)) {\n      const hasDuplicates = ancestors.get(instance)?.some((p) => breadcrumbs.join(\".\").startsWith(p));\n      if (hasDuplicates) {\n        callback(breadcrumbs, {\n          ...getContextPointer(breadcrumbs),\n          value: \"[Circular]\"\n        });\n        return;\n      }\n    }\n    if (instance && !isFinalNode(instance)) {\n      if (ancestors.has(instance)) {\n        ancestors.set(instance, []);\n      }\n      ancestors.set(instance, [\n        ...ancestors.get(instance) ?? [],\n        breadcrumbs.join(\".\")\n      ]);\n    }\n    if (isFinalNode(instance)) {\n      callback(breadcrumbs, {\n        ...getContextPointer(breadcrumbs),\n        value: instance\n      });\n      return;\n    }\n    const encoder = encoders.find((_encoder) => _encoder.shouldUse(instance)) ?? objectEncoder;\n    if (encoder) {\n      encoder.serialize(instance, (key, value) => {\n        iterateStructure(value, [\n          ...breadcrumbs,\n          `${ENCODER_MARKER}${encoder.marker}`,\n          key\n        ]);\n      });\n      return;\n    }\n  };\n  return iterateStructure(root);\n}\nconst serialize = (input, registerFunctionMarker) => {\n  if (!isSerializableType(input)) {\n    throw new Error(\n      errorMessage(\"only objects are serializable at the root level\")\n    );\n  }\n  const buffer = {\n    data: []\n  };\n  const appendValue = (path, value) => {\n    buffer.data.push([path, value]);\n  };\n  const appendFunction = (path, config) => {\n    registerFunctionMarker(beautifyPath(path), (...args) => {\n      return config.context[config.pointer](...args);\n    });\n    appendValue(path, FUNCTION_MARKER);\n  };\n  forEachMember(input, (breadcrumbs, { value, context, pointer }) => {\n    const path = breadcrumbs.slice(1).join(PATH_SEPARATOR);\n    const descriptor = getDescriptor(context, pointer);\n    if (descriptor?.get || descriptor?.set) {\n      if (descriptor?.get) {\n        registerFunctionMarker(\n          beautifyBreadcrumbs([...breadcrumbs, ACCESSOR_GET_POINTER]),\n          () => context[pointer]\n        );\n      }\n      if (descriptor?.set) {\n        registerFunctionMarker(\n          beautifyBreadcrumbs([...breadcrumbs, ACCESSOR_SET_POINTER]),\n          (_value) => {\n            context[pointer] = _value;\n          }\n        );\n      }\n      const marker = [\n        descriptor?.get ? WITH_ACCESSOR_INDICATOR : NO_ACCESSOR_INDICATOR,\n        descriptor?.set ? WITH_ACCESSOR_INDICATOR : NO_ACCESSOR_INDICATOR\n      ];\n      appendValue(path, `${ACCESSOR_MARKER}${marker.join(\"\")}`);\n    } else if (typeof value === \"function\") {\n      appendFunction(path, { context, pointer });\n    } else {\n      appendValue(path, value);\n    }\n  });\n  return buffer;\n};\nconst deserialize = (input, replaceFunctionMarker) => {\n  if (typeof input !== \"object\" || input === null) {\n    return input;\n  }\n  return input.data.reduce(\n    (acc, [breadcrumbs, value]) => {\n      let pointer = acc;\n      const pointers = breadcrumbs.split(PATH_SEPARATOR);\n      let encoder = objectEncoder;\n      let key = null;\n      for (let i = 0; i < pointers.length; i++) {\n        const point = pointers[i];\n        if (point[0] === ENCODER_MARKER) {\n          const has = encoder.deserialize.has(pointer, key);\n          encoder = [objectEncoder, ...encoders].find(\n            (_iterator) => _iterator.marker === point[1]\n          );\n          if (!encoder) {\n            throw new Error(errorMessage(`unknown marker \"${point[1]}\"`));\n          }\n          if (!has) {\n            pointer[key] = encoder.deserialize.create();\n          }\n          pointer = pointer[key];\n        } else {\n          key = point;\n        }\n      }\n      if (value?.toString() === ENCODER_EMPTY_MARKER) {\n        return acc;\n      } else if (value?.toString() === FUNCTION_MARKER) {\n        encoder.deserialize.append(\n          pointer,\n          key,\n          replaceFunctionMarker(beautifyBreadcrumbs(pointers))\n        );\n      } else if (value?.toString()[0] === ACCESSOR_MARKER) {\n        const hasGetter = value?.toString()[1] === WITH_ACCESSOR_INDICATOR;\n        const hasSetter = value?.toString()[2] === WITH_ACCESSOR_INDICATOR;\n        const descriptor = {};\n        if (hasGetter) {\n          const getter = replaceFunctionMarker(\n            beautifyBreadcrumbs([...pointers, ACCESSOR_GET_POINTER])\n          );\n          descriptor.get = () => getter();\n        }\n        if (hasSetter) {\n          descriptor.set = replaceFunctionMarker(\n            beautifyBreadcrumbs([...pointers, ACCESSOR_SET_POINTER])\n          );\n        }\n        Object.defineProperty(pointer, key, descriptor);\n      } else {\n        encoder.deserialize.append(pointer, key, value);\n      }\n      return acc;\n    },\n    // TODO: define as enumrable\n    {\n      [Symbol(\"transferred object\")]: `${(JSON.stringify(input.data).length / 1024).toFixed(2)}Kb`\n    }\n  );\n};\n\nvar MessageType = /* @__PURE__ */ ((MessageType2) => {\n  MessageType2[\"ExposeAPI\"] = \"ExposeAPI\";\n  MessageType2[\"Call\"] = \"Call\";\n  MessageType2[\"Response\"] = \"Response\";\n  MessageType2[\"Cleanup\"] = \"Cleanup\";\n  return MessageType2;\n})(MessageType || {});\nclass Message {\n  constructor(type, payload) {\n    this.type = type;\n    this.payload = payload;\n  }\n  correlationId = `M-${performance.now()}`;\n  parentCorrelationId;\n  withParentCorrelationId(correlationId) {\n    this.parentCorrelationId = correlationId;\n    return this;\n  }\n  serialize(registerFunctionMarker) {\n    return JSON.stringify({\n      parentCorrelationId: this.parentCorrelationId,\n      correlationId: this.correlationId,\n      type: this.type,\n      payload: serialize(this.payload, (path, value) => {\n        registerFunctionMarker(this.correlationId, path, value);\n      })\n    });\n  }\n  static fromEvent(data, replaceFunctionMarker) {\n    const parsed = JSON.parse(data);\n    return new Message(\n      parsed.type,\n      deserialize(parsed.payload, (breadcrumbs) => {\n        return replaceFunctionMarker(parsed.correlationId, breadcrumbs);\n      })\n    ).withParentCorrelationId(parsed.correlationId);\n  }\n}\nclass MessageCleanup extends Message {\n  constructor(payload) {\n    super(\"Cleanup\" /* Cleanup */, payload);\n  }\n}\nclass MessageResponse extends Message {\n  constructor(payload) {\n    super(\"Response\" /* Response */, payload);\n  }\n}\nclass MessageResponseError extends Message {\n  constructor(payload) {\n    super(\"Response\" /* Response */, payload);\n  }\n}\nclass MessageCall extends Message {\n  constructor(payload) {\n    super(\"Call\" /* Call */, payload);\n  }\n}\n\nconst buildFunctionMarkerKey = (correlationId, path) => {\n  return `${correlationId}_${path}`;\n};\nclass ThreadChannel {\n  constructor(handshake) {\n    this.handshake = handshake;\n  }\n  #registry = new FinalizationRegistry((params) => {\n    this.postMessage(new MessageCleanup(params));\n  });\n  #messageEvents = {\n    [MessageType.Cleanup]: (message) => {\n      const functionMarkerKey = message.payload.functionMarkerKey;\n      const callId = message.payload.callId;\n      delete this.#functionMarkers[functionMarkerKey];\n      if (callId) {\n        delete this.#pendingFunctionResponse[callId];\n      }\n    },\n    /**\n     * Return function response between threads\n     */\n    [MessageType.Response]: async (message) => {\n      const callId = message.payload.callId;\n      const _errorMessage = message.payload.errorMessage;\n      if (_errorMessage) {\n        const errorStack = message.payload.errorStack;\n        if (errorStack) {\n          const error = new Error(_errorMessage);\n          error.stack = message.payload.errorStack;\n          this.#pendingFunctionResponse[callId]?.reject(error);\n        } else {\n          this.#pendingFunctionResponse[callId]?.reject(_errorMessage);\n        }\n      } else {\n        const response = message.payload.response;\n        this.#pendingFunctionResponse[callId]?.resolve(response);\n      }\n      delete this.#pendingFunctionResponse[callId];\n    },\n    /**\n     * Calling function between threads\n     */\n    [MessageType.Call]: async (message) => {\n      const functionMarkerKey = message.payload.functionMarkerKey;\n      const marker = this.#functionMarkers[functionMarkerKey];\n      if (!marker) {\n        this.postMessage(\n          new MessageResponseError({\n            callId: message.payload.callId,\n            errorMessage: errorMessage(\"function is not available\")\n          })\n        );\n        return;\n      }\n      try {\n        const response = await marker.value(...message.payload.props ?? []);\n        this.postMessage(\n          new MessageResponse({\n            callId: message.payload.callId,\n            response\n          })\n        );\n      } catch (error) {\n        this.postMessage(\n          new MessageResponseError({\n            callId: message.payload.callId,\n            /**\n             * for better DX we need to pass Error object to keep stack trace available\n             * but in some cases our custom error messages are not serialized correctly\n             */\n            errorMessage: error.message,\n            errorStack: error.stack\n          })\n        );\n      }\n    }\n  };\n  #functionMarkers = {};\n  #pendingFunctionResponse = {};\n  queue = [];\n  isConnected = false;\n  async run(port) {\n    return this.handshake.run(port);\n  }\n  registerMessageListener() {\n    if (!this.port) {\n      throw new Error(\n        internalErrorMessage(\n          \"it is not possible to listen on port events because port is not defined\"\n        )\n      );\n    }\n    this.port.onmessage = (e) => {\n      this.onMessage(e);\n    };\n  }\n  onMessage(event) {\n    const message = Message.fromEvent(event.data, (correlationId, path) => {\n      const replacedFunction = this.replaceTransferredFunction(\n        correlationId,\n        path\n      );\n      this.#registry.register(replacedFunction, {\n        functionMarkerKey: buildFunctionMarkerKey(correlationId, path)\n        // callId: message.payload?.callId,\n      });\n      return replacedFunction;\n    });\n    this.#messageEvents[message.type]?.(message);\n    this.messageEvents[message.type]?.(message);\n  }\n  postMessage(message) {\n    if (!this.port) {\n      throw new Error(\n        internalErrorMessage(\n          \"it is not possible to post message on port because port is not defined\"\n        )\n      );\n    }\n    this.port.postMessage(\n      message.serialize(this.registerTransferredFunction.bind(this))\n    );\n  }\n  registerTransferredFunction(correlationId, path, value) {\n    const functionMarkerKey = buildFunctionMarkerKey(correlationId, path);\n    this.#functionMarkers[functionMarkerKey] = {\n      path,\n      value\n    };\n  }\n  replaceTransferredFunction(correlationId, path) {\n    return (...props) => {\n      const callId = `CALL-${crypto.randomUUID()}`;\n      this.postMessage(\n        new MessageCall({\n          callId,\n          functionMarkerKey: buildFunctionMarkerKey(correlationId, path),\n          props\n        })\n      );\n      return new Promise((resolve, reject) => {\n        this.#pendingFunctionResponse[callId] = { resolve, reject };\n      });\n    };\n  }\n  flush() {\n    if (!this.port) {\n      return;\n    }\n    this.queue.forEach((message) => {\n      this.postMessage(message);\n    });\n    this.queue = [];\n  }\n}\n\nclass ConsumerChannel extends ThreadChannel {\n  port = void 0;\n  messageEvents = {};\n  constructor(handshake) {\n    super(handshake);\n    void this.init();\n  }\n  async init() {\n    const port = await this.run();\n    if (port) {\n      this.port = port;\n      this.registerMessageListener();\n      this.flush();\n    } else {\n      console.error(\n        internalErrorMessage(\n          \"consumer did not receive message port from the host\"\n        )\n      );\n    }\n  }\n  expose(instance) {\n    if (!instance.type) {\n      throw new Error(\n        errorMessage('wrong exposed API instance, \"type\" property is required')\n      );\n    }\n    this.queue.push(new Message(MessageType.ExposeAPI, instance));\n    this.flush();\n  }\n}\n\nclass HostChannel extends ThreadChannel {\n  #consumerAPIInstances = {};\n  #consumerAPIInstancesResolvers = [];\n  #messageChannel = new MessageChannel();\n  port = this.#messageChannel.port1;\n  messageEvents = {\n    [MessageType.ExposeAPI]: (message) => {\n      const pendingTypeInstances = this.#consumerAPIInstancesResolvers.filter(\n        ({ type }) => type === message.payload.type\n      );\n      this.#consumerAPIInstancesResolvers = this.#consumerAPIInstancesResolvers.filter(\n        ({ type }) => type !== message.payload.type\n      );\n      pendingTypeInstances.forEach(({ cb }) => {\n        cb(message.payload);\n      });\n    }\n  };\n  constructor(handshake) {\n    super(handshake);\n    void this.init();\n  }\n  async init() {\n    await this.run(this.#messageChannel.port2);\n    this.registerMessageListener();\n  }\n  waitAPI(type) {\n    return new Promise((resolve) => {\n      this.onAPICallback(type, (_workerApi) => {\n        resolve(_workerApi);\n      });\n    });\n  }\n  onAPICallback(type, cb) {\n    if (this.#consumerAPIInstances[type]) {\n      cb(this.#consumerAPIInstances[type]);\n      return;\n    }\n    this.#consumerAPIInstancesResolvers.push({\n      type,\n      cb\n    });\n  }\n}\n\nclass AbstractHandshake {\n  constructor(communicationAPI) {\n    this.communicationAPI = communicationAPI;\n  }\n}\n\nclass BothDirectionalHandshake extends AbstractHandshake {\n  static iframe = {\n    host: (frame) => {\n      return new BothDirectionalHandshake({\n        postMessage: (message, ports) => {\n          const contentWindow = frame.contentWindow;\n          if (!contentWindow) {\n            return;\n          }\n          contentWindow.postMessage(message, \"*\", ports);\n        },\n        onMessage: (cb) => {\n          const _cb = (event) => {\n            if (event.origin !== new URL(frame.src).origin || frame.contentWindow !== event.source) {\n              return;\n            }\n            cb(event);\n          };\n          globalThis.addEventListener(\"message\", _cb);\n          return () => globalThis.removeEventListener(\"message\", _cb);\n        }\n      });\n    },\n    consumer: () => {\n      return new BothDirectionalHandshake({\n        postMessage: (message) => {\n          globalThis.parent.postMessage(message, \"*\");\n        },\n        onMessage: (cb) => {\n          globalThis.addEventListener(\"message\", cb);\n          return () => {\n            globalThis.removeEventListener(\"message\", cb);\n          };\n        }\n      });\n    }\n  };\n  static worker = {\n    host: (worker) => {\n      return new BothDirectionalHandshake({\n        postMessage: (message, ports) => {\n          worker.postMessage(message, ports);\n        },\n        onMessage: (cb) => {\n          worker.addEventListener(\"message\", cb);\n          return () => worker.removeEventListener(\"message\", cb);\n        }\n      });\n    },\n    consumer: () => {\n      return new BothDirectionalHandshake({\n        postMessage: (message) => {\n          globalThis.postMessage(message);\n        },\n        onMessage: (cb) => {\n          globalThis.addEventListener(\"message\", cb);\n          return () => {\n            globalThis.removeEventListener(\"message\", cb);\n          };\n        }\n      });\n    }\n  };\n  #unsubscribe;\n  #isConnected = false;\n  run(port) {\n    return new Promise((resolve) => {\n      if (port) {\n        this.#startAsHost(port, () => resolve(void 0));\n      } else {\n        this.#startAsConsumer(resolve);\n      }\n    });\n  }\n  #startAsHost(port, resolve) {\n    if (!port) {\n      throw new Error(\n        internalErrorMessage(\"port should exists on host handshake\")\n      );\n    }\n    const memberId = \"Host\" /* Host */;\n    this.communicationAPI.postMessage(\n      JSON.stringify({\n        memberId,\n        type: \"Greeting\" /* Greeting */\n      }),\n      []\n    );\n    this.#subscribe(memberId, (message) => {\n      switch (message.type) {\n        /**\n         * on Greeting event from consumer response with Greeting from host\n         * Consumer should send RequestPort event\n         */\n        case \"Greeting\" /* Greeting */: {\n          this.communicationAPI.postMessage(\n            JSON.stringify({\n              memberId,\n              type: \"Greeting\" /* Greeting */\n            }),\n            []\n          );\n          break;\n        }\n        /**\n         * on RequestPort event from consumer\n         * response with the port\n         */\n        case \"RequestPort\" /* RequestPort */: {\n          if (this.#isConnected) {\n            return;\n          }\n          this.#isConnected = true;\n          this.communicationAPI.postMessage(\n            JSON.stringify({\n              memberId,\n              type: \"Port\" /* Port */\n            }),\n            [port]\n          );\n          this.#unsubscribe?.();\n          resolve();\n          break;\n        }\n      }\n    });\n  }\n  #startAsConsumer(resolve) {\n    const memberId = \"Consumer\" /* Consumer */;\n    this.communicationAPI.postMessage(\n      JSON.stringify({\n        memberId,\n        type: \"Greeting\" /* Greeting */\n      }),\n      []\n    );\n    this.#subscribe(memberId, (message, port) => {\n      switch (message.type) {\n        /**\n         * on Greeting from host\n         * response with simple RequestPort\n         */\n        case \"Greeting\" /* Greeting */: {\n          this.communicationAPI.postMessage(\n            JSON.stringify({\n              memberId,\n              type: \"RequestPort\" /* RequestPort */\n            }),\n            []\n          );\n          break;\n        }\n        /**\n         * on Port from host\n         * consumer should receive the port\n         */\n        case \"Port\" /* Port */: {\n          this.#isConnected = true;\n          this.#unsubscribe?.();\n          resolve(port);\n          break;\n        }\n      }\n    });\n  }\n  #subscribe(memberId, cb) {\n    this.#unsubscribe?.();\n    this.#unsubscribe = this.communicationAPI.onMessage((event) => {\n      try {\n        const message = typeof event.data === \"string\" ? JSON.parse(event.data) : {};\n        if (!message.memberId || message.memberId === memberId) {\n          return;\n        }\n        cb(message, event.ports[0]);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n}\n\nclass IFrameConsumerChannel extends ConsumerChannel {\n  constructor() {\n    super(BothDirectionalHandshake.iframe.consumer());\n  }\n}\n\nclass IFrameHostChannel extends HostChannel {\n  constructor(frame) {\n    super(BothDirectionalHandshake.iframe.host(frame));\n  }\n}\n\nclass WorkerConsumerChannel extends ConsumerChannel {\n  constructor() {\n    super(BothDirectionalHandshake.worker.consumer());\n  }\n}\n\nclass WorkerHostChannel extends HostChannel {\n  constructor(worker) {\n    super(BothDirectionalHandshake.worker.host(worker));\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-platform-transport/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/@wix/editor/dist/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@wix/editor/dist/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   application: () => (/* binding */ index$4),\n/* harmony export */   components: () => (/* binding */ components),\n/* harmony export */   editor: () => (/* binding */ editor),\n/* harmony export */   events: () => (/* binding */ index$3),\n/* harmony export */   info: () => (/* binding */ index$2),\n/* harmony export */   inputs: () => (/* binding */ index),\n/* harmony export */   widget: () => (/* binding */ index$1)\n/* harmony export */ });\n/* harmony import */ var _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wix/public-editor-platform-errors */ \"./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs\");\n/* harmony import */ var _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wix/public-editor-platform-events */ \"./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs\");\n/* harmony import */ var _wix_editor_platform_transport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wix/editor-platform-transport */ \"./node_modules/@wix/editor-platform-transport/dist/esm/index.js\");\n/* harmony import */ var _wix_editor_application_platform_frame_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/editor-application/platform-frame-api */ \"./node_modules/@wix/editor-application/dist/esm/platform-frame-api/index.js\");\n/* harmony import */ var _wix_editor_application_platform_worker_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/editor-application/platform-worker-api */ \"./node_modules/@wix/editor-application/dist/esm/platform-worker-api/index.js\");\n/* harmony import */ var _wix_sdk_runtime_host_modules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wix/sdk-runtime/host-modules */ \"./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/host-modules.js\");\n\n\n\n\n\n\n\nvar EditorPlatformApplicationContextErrorCode = /* @__PURE__ */ ((EditorPlatformApplicationContextErrorCode2) => {\n  EditorPlatformApplicationContextErrorCode2[\"IncorrectEnvironment\"] = \"IncorrectEnvironment\";\n  EditorPlatformApplicationContextErrorCode2[\"ClientAuthError\"] = \"ClientAuthError\";\n  return EditorPlatformApplicationContextErrorCode2;\n})(EditorPlatformApplicationContextErrorCode || {});\nclass EditorPlatformApplicationContextError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Editor Platform Application Context Error\");\n  }\n  withUrl(url) {\n    this.state = { ...this.state, url };\n    return this;\n  }\n  withAppDefinitionId(appDefinitionId) {\n    this.state = { ...this.state, appDefinitionId };\n    return this;\n  }\n}\nconst createEditorPlatformApplicationContextError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.createErrorBuilder)(EditorPlatformApplicationContextError);\nasync function transformEventPayload(eventPayload, privateAPI) {\n  if (!eventPayload?.type) {\n    return eventPayload;\n  }\n  switch (eventPayload.type) {\n    case \"componentSelectionChanged\":\n      const componentRefs = eventPayload.componentRefs || [];\n      const components = await Promise.all(\n        componentRefs.map((ref) => {\n          return privateAPI.components.getComponent(ref);\n        })\n      );\n      return {\n        type: eventPayload.type,\n        components\n      };\n    default:\n      return eventPayload;\n  }\n}\nclass ApplicationBoundEvents {\n  constructor(appDefinitionId, events, privateAPI) {\n    this.appDefinitionId = appDefinitionId;\n    this.privateAPI = privateAPI;\n    this.events = events;\n    this.subscribe = events.subscribe.bind(events);\n    this.commit = events.commit.bind(events);\n    this.startTransaction = events.startTransaction.bind(events);\n    this.silent = events.silent.bind(events);\n  }\n  events;\n  subscribe;\n  commit;\n  startTransaction;\n  silent;\n  notify(event) {\n    this.events.notify({\n      type: event.type,\n      payload: event.payload,\n      meta: {\n        appDefinitionId: this.appDefinitionId\n      }\n    });\n  }\n  notifyCustomEvent(type, payload) {\n    this.notify({\n      type: _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_3__.PlatformAppEvent.CustomEvent,\n      payload: {\n        ...payload,\n        type\n      }\n    });\n  }\n  /**\n   * TODO: we should use same interface for all events\n   * (subscribe vs addEventListener)\n   */\n  addEventListener(eventType, fn) {\n    return this.events.subscribe(async (event) => {\n      const isAppMatch = event.meta?.appDefinitionId === this.appDefinitionId || event.meta?.appDefinitionId === null;\n      const transformPayload = () => transformEventPayload(event.payload, this.privateAPI);\n      if (eventType === \"*\") {\n        fn(await transformPayload());\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_3__.PlatformAppEvent.CustomEvent) {\n        if (eventType === event.payload?.type && !isAppMatch) {\n          fn(await transformPayload());\n        }\n      } else if (event.type === _wix_public_editor_platform_events__WEBPACK_IMPORTED_MODULE_3__.PlatformAppEvent.HostEvent) {\n        if (eventType === event.payload?.type && isAppMatch) {\n          fn(await transformPayload());\n        }\n      }\n    });\n  }\n}\nconst WAIT_INJECTED_TIMEOUT = 200;\nconst WAIT_INJECTED_RETRY_COUNT = 50;\nclass ContextInjectionStatus {\n  _resolveContextInjected = () => {\n  };\n  _isInjected = false;\n  key;\n  constructor(uuid) {\n    this.key = `__${uuid}_CONTEXT_INJECTION_STATUS_KEY`;\n    if (!globalThis[this.key]) {\n      globalThis[this.key] = new Promise((resolve) => {\n        this._resolveContextInjected = () => {\n          this._isInjected = true;\n          resolve();\n        };\n      });\n    }\n  }\n  isInjected() {\n    return !!this._isInjected;\n  }\n  resolveInjected() {\n    this._resolveContextInjected?.();\n  }\n  waitInjected() {\n    return new Promise((resolve, reject) => {\n      let injected = false;\n      let timeoutId;\n      let retryCount = 0;\n      const timeout = () => {\n        if (injected) {\n          return;\n        }\n        timeoutId = setTimeout(() => {\n          retryCount++;\n          if (retryCount < WAIT_INJECTED_RETRY_COUNT) {\n            if (retryCount % 10 === 0) {\n              console.log(\n                createEditorPlatformApplicationContextError(\n                  EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n                  \"contexts are not resolved, still re-trying\"\n                ).withMessage(`try number ${retryCount}`).message\n              );\n            }\n            timeout();\n            return;\n          }\n          if (!injected) {\n            const error = createEditorPlatformApplicationContextError(\n              EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n              \"contexts are not resolved, threw by timeout\"\n            );\n            reject(error);\n          }\n        }, WAIT_INJECTED_TIMEOUT);\n      };\n      timeout();\n      const _waitContextInjectedPromise = globalThis[this.key];\n      _waitContextInjectedPromise.then(() => {\n        injected = true;\n        clearTimeout(timeoutId);\n        resolve();\n      });\n    });\n  }\n}\nconst ENVIRONMENT_CONTEXT_KEY = \"__ENVIRONMENT_CONTEXT_KEY\";\nvar PlatformEnvironment = /* @__PURE__ */ ((PlatformEnvironment2) => {\n  PlatformEnvironment2[\"Worker\"] = \"Worker\";\n  PlatformEnvironment2[\"Frame\"] = \"Frame\";\n  PlatformEnvironment2[\"ComponentPanel\"] = \"ComponentPanel\";\n  return PlatformEnvironment2;\n})(PlatformEnvironment || {});\nclass EnvironmentContext {\n  constructor(environmentContext) {\n    this.environmentContext = environmentContext;\n  }\n  static status = new ContextInjectionStatus(\"environment\");\n  static async inject(context) {\n    if (globalThis[ENVIRONMENT_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Environment context already exists and should not be overridden\"\n      );\n    }\n    globalThis[ENVIRONMENT_CONTEXT_KEY] = new EnvironmentContext(context);\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    await this.status.waitInjected();\n    return globalThis[ENVIRONMENT_CONTEXT_KEY];\n  }\n  getPrivateAPI() {\n    return this.environmentContext.privateApi;\n  }\n  getEvents() {\n    return this.environmentContext.events;\n  }\n  getApplicationAPIs() {\n    return this.environmentContext.applicationAPIs ?? {};\n  }\n  getEnvironment() {\n    return this.environmentContext.environment;\n  }\n}\nconst APPLICATION_CONTEXT_KEY = \"__APPLICATION_CONTEXT_KEY\";\nclass ApplicationContext {\n  constructor(applicationContext, environment) {\n    this.applicationContext = applicationContext;\n    this.environment = environment;\n    this.events = new ApplicationBoundEvents(\n      this.applicationContext.appDefinitionId,\n      this.environment.getEvents(),\n      this.environment.getPrivateAPI()\n    );\n  }\n  static status = new ContextInjectionStatus(\"application\");\n  /**\n   * TODO: use generics for context type\n   * - application\n   * - editor\n   */\n  static async inject(context) {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() !== PlatformEnvironment.Frame) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context can be injected only in frame environment\"\n      );\n    }\n    if (globalThis[APPLICATION_CONTEXT_KEY]) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"Application context already exists and should not be overridden\"\n      );\n    }\n    globalThis[APPLICATION_CONTEXT_KEY] = new ApplicationContext(\n      context,\n      await EnvironmentContext.getInstance()\n    );\n    this.status.resolveInjected();\n  }\n  static async getInstance() {\n    const environment = await EnvironmentContext.getInstance();\n    if (environment.getEnvironment() === PlatformEnvironment.Frame) {\n      await this.status.waitInjected();\n      return globalThis[APPLICATION_CONTEXT_KEY];\n    } else {\n      return __APPLICATION_CONTEXT_KEY;\n    }\n  }\n  events;\n  getAppDefinitionId() {\n    return this.applicationContext.appDefinitionId;\n  }\n  getBindings() {\n    return this.applicationContext;\n  }\n  getEvents() {\n    return this.events;\n  }\n  getPrivateAPI() {\n    return this.environment.getPrivateAPI();\n  }\n  getPrivateApplicationAPI() {\n    const appDefinitionId = this.getAppDefinitionId();\n    if (!appDefinitionId) {\n      throw createEditorPlatformApplicationContextError(\n        EditorPlatformApplicationContextErrorCode.IncorrectEnvironment,\n        \"appDefinitionId is not available\"\n      );\n    }\n    return this.environment.getApplicationAPIs()[appDefinitionId];\n  }\n}\n\nclass EditorPlatformSDKAuthError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Auth Strategy Error\");\n  }\n  withAppDefinitionId(appDefinitionId) {\n    this.state = { ...this.state, appDefinitionId };\n    return this;\n  }\n}\nconst createAuthStrategyShapeError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.createErrorBuilder)(EditorPlatformSDKAuthError);\nconst auth = () => {\n  return {\n    getAuthHeaders: async () => {\n      const context = await ApplicationContext.getInstance();\n      const privateAPI = context.getPrivateAPI();\n      const bindings = context.getBindings();\n      if (!bindings.appDefinitionId) {\n        throw createAuthStrategyShapeError(\n          \"EmptyAppDefinitionId\" /* EmptyAppDefinitionId */\n        );\n      }\n      const authInstance = await privateAPI.info.getAppInstance(\n        bindings.appDefinitionId\n      );\n      if (authInstance === void 0) {\n        throw createAuthStrategyShapeError(\n          \"EmptyAppAuthInstance\" /* EmptyAppAuthInstance */\n        ).withAppDefinitionId(bindings.appDefinitionId);\n      }\n      return {\n        headers: {\n          Authorization: authInstance\n        }\n      };\n    }\n  };\n};\n\nconst isWorker = typeof importScripts === \"function\";\nif (isWorker) {\n  const channel = new _wix_editor_platform_transport__WEBPACK_IMPORTED_MODULE_4__.WorkerConsumerChannel();\n  channel.expose(new _wix_editor_application_platform_worker_api__WEBPACK_IMPORTED_MODULE_1__.PlatformWorkerAPI());\n} else {\n  const channel = new _wix_editor_platform_transport__WEBPACK_IMPORTED_MODULE_4__.IFrameConsumerChannel();\n  channel.expose(new _wix_editor_application_platform_frame_api__WEBPACK_IMPORTED_MODULE_0__.PlatformFrameAPI());\n}\n\nclass PlatformSDKShape {\n  constructor(namespace, shape) {\n    this.namespace = namespace;\n    this.shape = shape;\n  }\n  build() {\n    return (0,_wix_sdk_runtime_host_modules__WEBPACK_IMPORTED_MODULE_5__.createHostModule)(\n      Object.fromEntries(\n        Object.entries(this.shape).map(([key, value]) => [\n          key,\n          (host) => {\n            if (host?.environmentContext && host?.applicationContext) {\n              return value({\n                environmentContext: host.environmentContext,\n                applicationContext: host.applicationContext\n              });\n            }\n            return async (...args) => {\n              const environmentContext = await EnvironmentContext.getInstance();\n              const applicationContext = await ApplicationContext.getInstance();\n              return value({\n                environmentContext,\n                applicationContext\n              })(...args);\n            };\n          }\n        ])\n      )\n    );\n  }\n}\n\nconst applicationShape = new PlatformSDKShape(\"application\", {\n  getPrivateAPI({ applicationContext }) {\n    return async () => {\n      return applicationContext.getPrivateApplicationAPI();\n    };\n  },\n  getPublicAPI({ applicationContext }) {\n    return async (appDefinitionId) => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      return privateAPI.applicationManager.getPublicApplicationAPI(\n        appDefinitionId\n      );\n    };\n  },\n  getAppInstance({ applicationContext }) {\n    return async () => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      const bindings = applicationContext.getBindings();\n      return privateAPI.info.getAppInstance(bindings.appDefinitionId);\n    };\n  }\n});\nvar index$4 = applicationShape.build();\n\nconst componentsShape = new PlatformSDKShape(\"components\", {\n  getSelectedComponents({ applicationContext }) {\n    return async () => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      const refs = await privateAPI.components.getSelectedComponents();\n      return Promise.all(\n        refs.map((ref) => privateAPI.components.getComponent(ref))\n      );\n    };\n  }\n});\nvar components = componentsShape.build();\n\nconst eventsShape = new PlatformSDKShape(\"events\", {\n  addEventListener({ applicationContext }) {\n    return async (name, cb) => {\n      return applicationContext.getEvents().addEventListener(name, cb);\n    };\n  }\n});\nvar index$3 = eventsShape.build();\n\nconst infoShape = new PlatformSDKShape(\"info\", {\n  getViewMode({ applicationContext }) {\n    return async () => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      return privateAPI.info.getViewMode();\n    };\n  },\n  getLanguageCode({ applicationContext }) {\n    return async () => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      return privateAPI.info.getLanguageCode();\n    };\n  }\n});\nvar index$2 = infoShape.build();\n\nvar WidgetShapeErrorCode = /* @__PURE__ */ ((WidgetShapeErrorCode2) => {\n  WidgetShapeErrorCode2[\"UndefinedCompRef\"] = \"UndefinedCompRef\";\n  return WidgetShapeErrorCode2;\n})(WidgetShapeErrorCode || {});\nclass WidgetShapeError extends _wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n  constructor(message, code) {\n    super(message, code, \"Widget Error\");\n  }\n}\nconst createWidgetShapeError = (0,_wix_public_editor_platform_errors__WEBPACK_IMPORTED_MODULE_2__.createErrorBuilder)(WidgetShapeError);\n\nconst getSelectedComponentRef = async () => {\n  const selected = await components.getSelectedComponents();\n  const compRef = selected[0]?.compRef;\n  if (!compRef) {\n    throw createWidgetShapeError(WidgetShapeErrorCode.UndefinedCompRef);\n  }\n  return compRef;\n};\nconst widgetShape = new PlatformSDKShape(\"widget\", {\n  getProp({ applicationContext }) {\n    return async (propName) => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      const compRef = await getSelectedComponentRef();\n      return privateAPI.customElement.getAttribute(compRef, propName);\n    };\n  },\n  setProp({ applicationContext }) {\n    return async (propName, value) => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      const compRef = await getSelectedComponentRef();\n      await privateAPI.customElement.setAttribute(compRef, propName, value);\n    };\n  }\n});\nvar index$1 = widgetShape.build();\n\nconst fonts = {\n  transformFontInternalValue: (value) => {\n    if (value) {\n      const { theme, ...rest } = fonts.normalize(value);\n      return {\n        ...rest,\n        editorKey: theme\n      };\n    } else {\n      return {\n        editorKey: \"font_7\",\n        family: \"helvetica-w01-roman\",\n        size: 16,\n        style: {}\n      };\n    }\n  },\n  transformFontPublicValue: (value) => {\n    if (!value) {\n      return null;\n    }\n    return {\n      ...fonts.normalize(value),\n      theme: value.editorKey\n    };\n  },\n  normalize: ({\n    theme,\n    editorKey,\n    preset,\n    ...rest\n  }) => {\n    return {\n      ...rest,\n      theme: theme ?? editorKey\n    };\n  }\n};\nconst inputsShape = new PlatformSDKShape(\"inputs\", {\n  selectColor({ applicationContext }) {\n    return async (value, onColorChange) => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      let _value = value ? {\n        color: value.color,\n        theme: value?.theme\n      } : null;\n      await privateAPI.inputs.openColorPicker(\n        {\n          color: value?.theme ? value.theme : value?.color\n        },\n        ({\n          color,\n          theme\n        }) => {\n          const _color = { color, theme };\n          _value = _color;\n          onColorChange?.(_color);\n        }\n      );\n      return _value;\n    };\n  },\n  selectFont({ applicationContext }) {\n    return async (value, options, onFontChange) => {\n      const privateAPI = applicationContext.getPrivateAPI();\n      let _value = fonts.transformFontPublicValue(value);\n      const applyChanges = (...changes) => {\n        if (!_value) {\n          _value = fonts.transformFontPublicValue(\n            fonts.transformFontInternalValue(value)\n          );\n        }\n        switch (changes[0]) {\n          case \"theme\":\n            Object.assign(_value, {\n              theme: changes[1]\n            });\n            break;\n          case \"size\":\n            Object.assign(_value, {\n              size: changes[1]\n            });\n            break;\n          case \"bold\":\n            Object.assign(_value, {\n              style: {\n                ..._value.style,\n                bold: changes[1]\n              }\n            });\n            break;\n          case \"italic\":\n            Object.assign(_value, {\n              style: {\n                ..._value.style,\n                italic: changes[1]\n              }\n            });\n            break;\n          case \"underline\":\n            Object.assign(_value, {\n              style: {\n                ..._value.style,\n                underline: changes[1]\n              }\n            });\n            break;\n          case \"family\":\n            Object.assign(_value, {\n              family: changes[1]\n            });\n            break;\n        }\n      };\n      await privateAPI.inputs.openFontPicker(\n        {\n          ...options,\n          componentStyle: fonts.transformFontInternalValue(value)\n        },\n        (...changes) => {\n          applyChanges(...changes);\n          onFontChange?.(_value);\n        }\n      );\n      return _value;\n    };\n  }\n});\nvar index = inputsShape.build();\n\nconst editorPlatformFrameHost = () => {\n  return {\n    environment: {},\n    channel: {\n      observeState: async () => {\n        return { disconnect() {\n        } };\n      }\n    }\n  };\n};\n\nconst editorPlatformWorkerHost = () => {\n  return {\n    environment: {},\n    channel: {\n      observeState: async () => {\n        return { disconnect() {\n        } };\n      }\n    }\n  };\n};\n\nconst editor = {\n  host: () => {\n    const isWorker = typeof importScripts === \"function\";\n    if (isWorker) {\n      return editorPlatformWorkerHost();\n    }\n    return editorPlatformFrameHost();\n  },\n  auth\n};\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/@wix/public-editor-platform-interfaces/dist/EventType.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@wix/public-editor-platform-interfaces/dist/EventType.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventType = void 0;\n/**\n * Duplicated types from editor-platform-sdk-types/src/events/EventType.ts\n * to allow use them in public packages\n */\nvar EventType;\n(function (EventType) {\n    EventType[\"removeAppCompleted\"] = \"removeAppCompleted\";\n    EventType[\"componentSelectionChanged\"] = \"componentSelectionChanged\";\n    EventType[\"appInstalled\"] = \"appInstalled\";\n    EventType[\"appUpdateCompleted\"] = \"appUpdateCompleted\";\n})(EventType || (exports.EventType = EventType = {}));\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/public-editor-platform-interfaces/dist/EventType.js?");

/***/ }),

/***/ "./node_modules/@wix/public-editor-platform-interfaces/dist/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@wix/public-editor-platform-interfaces/dist/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventType = exports.WixSDKTypes = void 0;\nconst WixSDKTypes = __importStar(__webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\"));\nexports.WixSDKTypes = WixSDKTypes;\nvar EventType_1 = __webpack_require__(/*! ./EventType */ \"./node_modules/@wix/public-editor-platform-interfaces/dist/EventType.js\");\nObject.defineProperty(exports, \"EventType\", ({ enumerable: true, get: function () { return EventType_1.EventType; } }));\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/public-editor-platform-interfaces/dist/index.js?");

/***/ }),

/***/ "./src/panel.js":
/*!**********************!*\
  !*** ./src/panel.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wix_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/editor */ \"./node_modules/@wix/editor/dist/esm/index.js\");\n/* harmony import */ var _wix_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk */ \"./node_modules/@wix/sdk/build/wixClient.js\");\nconsole.log('before import');\n\n\n\n\n\nconsole.log('after import');\n\nconst client = (0,_wix_sdk__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n    host: _wix_editor__WEBPACK_IMPORTED_MODULE_1__.editor.host(),\n    modules: {\n        widget: _wix_editor__WEBPACK_IMPORTED_MODULE_1__.widget,\n    },\n});\n\nfunction updateColor(color) {\n    console.log(\"update color\")\n    client.widget.setProp('color', color);\n};\n\n//# sourceURL=webpack://test-1/./src/panel.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/ambassador-modules.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/ambassador-modules.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ambassadorModuleOptions: () => (/* binding */ ambassadorModuleOptions),\n/* harmony export */   isAmbassadorModule: () => (/* binding */ isAmbassadorModule),\n/* harmony export */   toHTTPModule: () => (/* binding */ toHTTPModule)\n/* harmony export */ });\nconst parseMethod = (method) => {\n    switch (method) {\n        case 'get':\n        case 'GET':\n            return 'GET';\n        case 'post':\n        case 'POST':\n            return 'POST';\n        case 'put':\n        case 'PUT':\n            return 'PUT';\n        case 'delete':\n        case 'DELETE':\n            return 'DELETE';\n        case 'patch':\n        case 'PATCH':\n            return 'PATCH';\n        case 'head':\n        case 'HEAD':\n            return 'HEAD';\n        case 'options':\n        case 'OPTIONS':\n            return 'OPTIONS';\n        default:\n            throw new Error(`Unknown method: ${method}`);\n    }\n};\nconst toHTTPModule = (factory) => (httpClient) => async (payload) => {\n    let requestOptions;\n    const HTTPFactory = (context) => {\n        requestOptions = factory(payload)(context);\n        if (requestOptions.url === undefined) {\n            throw new Error('Url was not successfully created for this request, please reach out to support channels for assistance.');\n        }\n        const { method, url, params } = requestOptions;\n        return {\n            ...requestOptions,\n            method: parseMethod(method),\n            url,\n            data: requestOptions.data,\n            params,\n        };\n    };\n    try {\n        const response = await httpClient.request(HTTPFactory);\n        if (requestOptions === undefined) {\n            throw new Error('Request options were not created for this request, please reach out to support channels for assistance.');\n        }\n        const transformations = Array.isArray(requestOptions.transformResponse)\n            ? requestOptions.transformResponse\n            : [requestOptions.transformResponse];\n        /**\n         * Based on Axios implementation:\n         * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/lib/core/transformData.js#L22\n         */\n        let data = response.data;\n        transformations.forEach((transform) => {\n            if (transform) {\n                data = transform(response.data, response.headers);\n            }\n        });\n        return data;\n    }\n    catch (e) {\n        if (typeof e === 'object' &&\n            e !== null &&\n            'response' in e &&\n            typeof e.response === 'object' &&\n            e.response !== null &&\n            'data' in e.response) {\n            throw e.response.data;\n        }\n        throw e;\n    }\n};\nconst ambassadorModuleOptions = () => ({\n    HTTPHost: self.location.host,\n});\n/*\n * Because of issues with tree-shaking, we cant really put static parameter on module.\n * We still have check for __isAmbassador for backward compatibility\n */\nconst isAmbassadorModule = (module) => {\n    if (module.__isAmbassador) {\n        return true;\n    }\n    const fn = module();\n    return Boolean(fn.__isAmbassador);\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/ambassador-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/bi/biHeaderGenerator.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/bi/biHeaderGenerator.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WixBIHeaderName: () => (/* binding */ WixBIHeaderName),\n/* harmony export */   biHeaderGenerator: () => (/* binding */ biHeaderGenerator)\n/* harmony export */ });\nconst WixBIHeaderName = 'x-wix-bi-gateway';\nfunction biHeaderGenerator(apiMetadata, publicMetadata) {\n    return {\n        [WixBIHeaderName]: objectToKeyValue({\n            environment: 'js-sdk',\n            'package-name': apiMetadata.packageName ?? publicMetadata?.PACKAGE_NAME,\n            'method-fqn': apiMetadata.methodFqn,\n            entity: apiMetadata.entityFqdn,\n        }),\n    };\n}\nfunction objectToKeyValue(input) {\n    return Object.entries(input)\n        .filter(([_, value]) => Boolean(value))\n        .map(([key, value]) => `${key}=${value}`)\n        .join(',');\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/bi/biHeaderGenerator.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/common.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/common.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_URL: () => (/* binding */ API_URL),\n/* harmony export */   FORCE_WRITE_API_URLS: () => (/* binding */ FORCE_WRITE_API_URLS),\n/* harmony export */   PUBLIC_METADATA_KEY: () => (/* binding */ PUBLIC_METADATA_KEY),\n/* harmony export */   READ_ONLY_API_URL: () => (/* binding */ READ_ONLY_API_URL)\n/* harmony export */ });\nconst PUBLIC_METADATA_KEY = '__metadata';\nconst API_URL = 'www.wixapis.com';\nconst READ_ONLY_API_URL = 'readonly.wixapis.com';\nconst FORCE_WRITE_API_URLS = ['/ecom/v1/carts/current'];\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/common.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/event-handlers-modules.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/event-handlers-modules.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildEventDefinition: () => (/* binding */ buildEventDefinition),\n/* harmony export */   eventHandlersModules: () => (/* binding */ eventHandlersModules),\n/* harmony export */   isEventHandlerModule: () => (/* binding */ isEventHandlerModule)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var nanoevents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoevents */ \"./node_modules/nanoevents/index.js\");\n\n\nconst isEventHandlerModule = (val) => val.__type === 'event-definition';\nfunction buildEventDefinition(eventDefinition, registerHandler) {\n    return (handler) => {\n        registerHandler(eventDefinition, handler);\n    };\n}\nfunction runHandler(eventDefinition, handler, payload, baseEventMetadata) {\n    let envelope;\n    if (eventDefinition.isDomainEvent) {\n        const domainEventPayload = payload;\n        const { deletedEvent, actionEvent, createdEvent, updatedEvent, ...domainEventMetadata } = domainEventPayload;\n        const metadata = {\n            ...baseEventMetadata,\n            ...domainEventMetadata,\n        };\n        if (deletedEvent) {\n            if (deletedEvent?.deletedEntity) {\n                envelope = {\n                    entity: deletedEvent?.deletedEntity,\n                    metadata,\n                };\n            }\n            else {\n                envelope = { metadata };\n            }\n        }\n        else if (actionEvent) {\n            envelope = {\n                data: actionEvent.body,\n                metadata,\n            };\n        }\n        else {\n            envelope = {\n                entity: createdEvent?.entity ?? updatedEvent?.currentEntity,\n                metadata,\n            };\n        }\n    }\n    else {\n        envelope = {\n            data: payload,\n            metadata: baseEventMetadata,\n        };\n    }\n    const transformFromRESTFn = eventDefinition.transformations ?? ((x) => x);\n    return handler(transformFromRESTFn(envelope));\n}\nfunction eventHandlersModules(authStrategy) {\n    const eventHandlers = new Map();\n    const webhooksEmitter = (0,nanoevents__WEBPACK_IMPORTED_MODULE_0__.createNanoEvents)();\n    const client = {\n        ...webhooksEmitter,\n        getRegisteredEvents: () => eventHandlers,\n        async process(jwt, opts = {\n            expectedEvents: [],\n        }) {\n            const { eventType, identity, instanceId, payload } = await this.parseJWT(jwt);\n            const allExpectedEvents = [\n                ...opts.expectedEvents,\n                ...Array.from(eventHandlers.keys()).map((type) => ({ type })),\n            ];\n            if (allExpectedEvents.length > 0 &&\n                !allExpectedEvents.some(({ type }) => type === eventType)) {\n                throw new Error(`Unexpected event type: ${eventType}. Expected one of: ${allExpectedEvents\n                    .map((x) => x.type)\n                    .join(', ')}`);\n            }\n            const handlers = eventHandlers.get(eventType) ?? [];\n            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, payload, {\n                instanceId,\n                identity,\n            })));\n            return {\n                instanceId,\n                eventType,\n                payload,\n                identity,\n            };\n        },\n        async processRequest(request, opts) {\n            const body = await request.text();\n            return this.process(body, opts);\n        },\n        async parseJWT(jwt) {\n            if (!authStrategy.decodeJWT) {\n                throw new Error('decodeJWT is not supported by the authentication strategy');\n            }\n            const { decoded, valid } = await authStrategy.decodeJWT(jwt);\n            if (!valid) {\n                throw new Error('JWT is not valid');\n            }\n            if (typeof decoded.data !== 'string') {\n                throw new Error(`Unexpected type of JWT data: expected string, got ${typeof decoded.data}`);\n            }\n            const parsedDecoded = JSON.parse(decoded.data);\n            const eventType = parsedDecoded.eventType;\n            const instanceId = parsedDecoded.instanceId;\n            const identity = parsedDecoded.identity\n                ? JSON.parse(parsedDecoded.identity)\n                : undefined;\n            const payload = JSON.parse(parsedDecoded.data);\n            return {\n                instanceId,\n                eventType,\n                payload,\n                identity,\n            };\n        },\n        async parseRequest(request) {\n            const jwt = await request.text();\n            return this.parseJWT(jwt);\n        },\n        async executeHandlers(event) {\n            const allExpectedEvents = Array.from(eventHandlers.keys()).map((type) => ({ type }));\n            if (allExpectedEvents.length > 0 &&\n                !allExpectedEvents.some(({ type }) => type === event.eventType)) {\n                throw new Error(`Unexpected event type: ${event.eventType}. Expected one of: ${allExpectedEvents\n                    .map((x) => x.type)\n                    .join(', ')}`);\n            }\n            const handlers = eventHandlers.get(event.eventType) ?? [];\n            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, event.payload, {\n                instanceId: event.instanceId,\n                identity: event.identity,\n            })));\n        },\n        apps: {\n            AppInstalled: (0,_wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__.EventDefinition)('AppInstalled')(),\n            AppRemoved: (0,_wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__.EventDefinition)('AppRemoved')(),\n        },\n    };\n    return {\n        initModule(eventDefinition) {\n            return (handler) => {\n                const handlers = eventHandlers.get(eventDefinition.type) ?? [];\n                handlers.push({ eventDefinition, handler });\n                eventHandlers.set(eventDefinition.type, handlers);\n                webhooksEmitter.emit('registered', eventDefinition);\n            };\n        },\n        client,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/event-handlers-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/fetch-error.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/fetch-error.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchErrorResponse: () => (/* binding */ FetchErrorResponse)\n/* harmony export */ });\nclass FetchErrorResponse extends Error {\n    message;\n    response;\n    constructor(message, response) {\n        super(message);\n        this.message = message;\n        this.response = response;\n    }\n    async details() {\n        const dataError = await this.response.json();\n        return errorBuilder(this.response.status, dataError?.message, dataError?.details, {\n            requestId: this.response.headers.get('X-Wix-Request-Id'),\n            details: dataError,\n        });\n    }\n}\nconst errorBuilder = (code, description, details, data) => {\n    return {\n        details: {\n            ...(!details?.validationError && {\n                applicationError: {\n                    description,\n                    code,\n                    data,\n                },\n            }),\n            ...details,\n        },\n        message: description,\n    };\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/fetch-error.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/helpers.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/helpers.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultContentHeader: () => (/* binding */ getDefaultContentHeader),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   parsePublicKeyIfEncoded: () => (/* binding */ parsePublicKeyIfEncoded)\n/* harmony export */ });\n// we follow a simplified version of the axios convention\n// https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/defaults/index.js#L65\nconst getDefaultContentHeader = (options) => {\n    if (options?.method &&\n        ['post', 'put', 'patch'].includes(options.method.toLocaleLowerCase()) &&\n        options.body) {\n        return { 'Content-Type': 'application/json' };\n    }\n    return {};\n};\nconst isObject = (val) => val && typeof val === 'object' && !Array.isArray(val);\nfunction parsePublicKeyIfEncoded(publicKey) {\n    if (publicKey.includes('\\n') || publicKey.includes('\\r')) {\n        // publicKey is multi-line string, can be used as is\n        return publicKey.trim();\n    }\n    else {\n        // publicKey is base64 encoded\n        return typeof atob !== 'undefined'\n            ? atob(publicKey)\n            : Buffer.from(publicKey, 'base64').toString('utf-8');\n    }\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/helpers.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/host-modules.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/host-modules.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildHostModule: () => (/* binding */ buildHostModule),\n/* harmony export */   isHostModule: () => (/* binding */ isHostModule)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/helpers.js\");\n\nconst isHostModule = (val) => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) && val.__type === 'host';\nfunction buildHostModule(val, host) {\n    return val.create(host);\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/host-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/rest-modules.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/rest-modules.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildRESTDescriptor: () => (/* binding */ buildRESTDescriptor),\n/* harmony export */   getDefaultDomain: () => (/* binding */ getDefaultDomain)\n/* harmony export */ });\n/* harmony import */ var _bi_biHeaderGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bi/biHeaderGenerator.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/bi/biHeaderGenerator.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/common.js\");\n\n\nconst getDefaultDomain = (_method, _url) => _common_js__WEBPACK_IMPORTED_MODULE_0__.API_URL;\nfunction buildRESTDescriptor(origFunc, publicMetadata, boundFetch, wixAPIFetch, options) {\n    return origFunc({\n        request: async (factory) => {\n            const requestOptions = factory({ host: options?.HTTPHost || _common_js__WEBPACK_IMPORTED_MODULE_0__.API_URL });\n            let request = requestOptions;\n            if (request.method === 'GET' &&\n                request.fallback?.length &&\n                request.params.toString().length > 4000) {\n                request = requestOptions.fallback[0];\n            }\n            const domain = options?.HTTPHost ?? getDefaultDomain(request.method, request.url);\n            let url = `https://${domain}${request.url}`;\n            if (request.params && request.params.toString()) {\n                url += `?${request.params.toString()}`;\n            }\n            try {\n                const biHeader = (0,_bi_biHeaderGenerator_js__WEBPACK_IMPORTED_MODULE_1__.biHeaderGenerator)(requestOptions, publicMetadata);\n                const res = await boundFetch(url, {\n                    method: request.method,\n                    ...(request.data && {\n                        body: JSON.stringify(request.data),\n                    }),\n                    headers: {\n                        ...biHeader,\n                    },\n                });\n                if (res.status !== 200) {\n                    let dataError = null;\n                    try {\n                        dataError = await res.json();\n                    }\n                    catch (e) {\n                        //\n                    }\n                    throw errorBuilder(res.status, dataError?.message, dataError?.details, {\n                        requestId: res.headers.get('X-Wix-Request-Id'),\n                        details: dataError,\n                    });\n                }\n                const data = await res.json();\n                return {\n                    data,\n                    headers: res.headers,\n                    status: res.status,\n                    statusText: res.statusText,\n                };\n            }\n            catch (e) {\n                if (e.message?.includes('fetch is not defined')) {\n                    console.error('Node.js v18+ is required');\n                }\n                throw e;\n            }\n        },\n        fetchWithAuth: boundFetch,\n        wixAPIFetch,\n    });\n}\nconst errorBuilder = (code, description, details, data) => {\n    return {\n        response: {\n            data: {\n                details: {\n                    ...(!details?.validationError && {\n                        applicationError: {\n                            description,\n                            code,\n                            data,\n                        },\n                    }),\n                    ...details,\n                },\n                message: description,\n            },\n            status: code,\n        },\n    };\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/rest-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/service-plugin-modules.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/service-plugin-modules.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isServicePluginModule: () => (/* binding */ isServicePluginModule),\n/* harmony export */   servicePluginsModules: () => (/* binding */ servicePluginsModules)\n/* harmony export */ });\n/* harmony import */ var nanoevents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoevents */ \"./node_modules/nanoevents/index.js\");\n\nconst isServicePluginModule = (val) => val.__type === 'service-plugin-definition';\nfunction servicePluginsModules(authStrategy) {\n    const servicePluginsImplementations = new Map();\n    const servicePluginsEmitter = (0,nanoevents__WEBPACK_IMPORTED_MODULE_0__.createNanoEvents)();\n    const client = {\n        ...servicePluginsEmitter,\n        getRegisteredServicePlugins: () => servicePluginsImplementations,\n        async parseJWT(jwt) {\n            if (!authStrategy.decodeJWT) {\n                throw new Error('decodeJWT is not supported by the authentication strategy');\n            }\n            const { decoded, valid } = await authStrategy.decodeJWT(jwt, true);\n            if (!valid) {\n                throw new Error('JWT is not valid');\n            }\n            if (typeof decoded.data !== 'object' ||\n                decoded.data === null ||\n                !('metadata' in decoded.data) ||\n                typeof decoded.data.metadata !== 'object' ||\n                decoded.data.metadata === null ||\n                !('appExtensionType' in decoded.data.metadata) ||\n                typeof decoded.data.metadata.appExtensionType !== 'string') {\n                throw new Error('Unexpected JWT data: expected object with metadata.appExtensionType string');\n            }\n            return decoded.data;\n        },\n        async process(request) {\n            const servicePluginRequest = await this.parseJWT(request.body);\n            return this.executeHandler(servicePluginRequest, request.url);\n        },\n        async parseRequest(request) {\n            const body = await request.text();\n            return this.parseJWT(body);\n        },\n        async processRequest(request) {\n            const url = request.url;\n            const body = await request.text();\n            const implMethodResult = await this.process({ url, body });\n            return Response.json(implMethodResult);\n        },\n        async executeHandler(servicePluginRequest, url) {\n            const componentType = servicePluginRequest.metadata.appExtensionType.toLowerCase();\n            const implementations = servicePluginsImplementations.get(componentType) ?? [];\n            if (implementations.length === 0) {\n                throw new Error(`No service plugin implementations found for component type ${componentType}`);\n            }\n            else if (implementations.length > 1) {\n                throw new Error(`Multiple service plugin implementations found for component type ${componentType}. This is currently not supported`);\n            }\n            const { implementation: impl, servicePluginDefinition } = implementations[0];\n            const method = servicePluginDefinition.methods.find((m) => url.endsWith(m.primaryHttpMappingPath));\n            if (!method) {\n                throw new Error('Unexpect request: request url did not match any method: ' + url);\n            }\n            const implMethod = impl[method.name];\n            if (!implMethod) {\n                throw new Error(`Got request for service plugin method ${method.name} but no implementation was provided. Available methods: ${Object.keys(impl).join(', ')}`);\n            }\n            return method.transformations.toREST(await implMethod(method.transformations.fromREST(servicePluginRequest)));\n        },\n    };\n    return {\n        initModule(servicePluginDefinition) {\n            return (implementation) => {\n                const implementations = servicePluginsImplementations.get(servicePluginDefinition.componentType.toLowerCase()) ?? [];\n                implementations.push({ servicePluginDefinition, implementation });\n                servicePluginsImplementations.set(servicePluginDefinition.componentType.toLowerCase(), implementations);\n                servicePluginsEmitter.emit('registered', servicePluginDefinition);\n            };\n        },\n        client,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/service-plugin-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/wixClient.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/wixClient.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @wix/sdk-context */ \"./node_modules/@wix/sdk-context/build/browser/index.mjs\");\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var _ambassador_modules_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ambassador-modules.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/ambassador-modules.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/common.js\");\n/* harmony import */ var _fetch_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./fetch-error.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/fetch-error.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/helpers.js\");\n/* harmony import */ var _host_modules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./host-modules.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/host-modules.js\");\n/* harmony import */ var _rest_modules_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rest-modules.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/rest-modules.js\");\n/* harmony import */ var _event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-handlers-modules.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/event-handlers-modules.js\");\n/* harmony import */ var _service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service-plugin-modules.js */ \"./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/service-plugin-modules.js\");\n\n\n\n\n\n\n\n\n\n\nfunction createClient(config) {\n    const _headers = config.headers || { Authorization: '' };\n    const authStrategy = config.auth ||\n        {\n            getAuthHeaders: (_) => Promise.resolve({ headers: {} }),\n        };\n    const boundGetAuthHeaders = authStrategy.getAuthHeaders.bind(undefined, config.host);\n    authStrategy.getAuthHeaders = boundGetAuthHeaders;\n    const { client: servicePluginsClient, initModule: initServicePluginModule } = (0,_service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__.servicePluginsModules)(authStrategy);\n    const { client: eventHandlersClient, initModule: initEventHandlerModule } = (0,_event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__.eventHandlersModules)(authStrategy);\n    const boundFetch = async (url, options) => {\n        const authHeaders = await boundGetAuthHeaders();\n        const defaultContentTypeHeader = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultContentHeader)(options);\n        return fetch(url, {\n            ...options,\n            headers: {\n                ...defaultContentTypeHeader,\n                ..._headers,\n                ...authHeaders?.headers,\n                ...options?.headers,\n            },\n        });\n    };\n    // This is typed as `any` because when trying to properly type it as defined\n    // on the WixClient, typescript starts failing with `Type instantiation is\n    // excessively deep and possibly infinite.`\n    const use = (modules, metadata) => {\n        if ((0,_event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__.isEventHandlerModule)(modules)) {\n            return initEventHandlerModule(modules);\n        }\n        else if ((0,_service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__.isServicePluginModule)(modules)) {\n            return initServicePluginModule(modules);\n        }\n        else if ((0,_host_modules_js__WEBPACK_IMPORTED_MODULE_3__.isHostModule)(modules) && config.host) {\n            return (0,_host_modules_js__WEBPACK_IMPORTED_MODULE_3__.buildHostModule)(modules, config.host);\n        }\n        else if (typeof modules === 'function') {\n            // The generated namespaces all have the error classes on them and\n            // a class is also a function, so we need to explicitly ignore these\n            // error classes using a static field that exists on them.\n            if ('__type' in modules && modules.__type === _wix_sdk_types__WEBPACK_IMPORTED_MODULE_4__.SERVICE_PLUGIN_ERROR_TYPE) {\n                return modules;\n            }\n            const { module, options } = (0,_ambassador_modules_js__WEBPACK_IMPORTED_MODULE_5__.isAmbassadorModule)(modules)\n                ? {\n                    module: (0,_ambassador_modules_js__WEBPACK_IMPORTED_MODULE_5__.toHTTPModule)(modules),\n                    options: (0,_ambassador_modules_js__WEBPACK_IMPORTED_MODULE_5__.ambassadorModuleOptions)(),\n                }\n                : { module: modules, options: undefined };\n            return (0,_rest_modules_js__WEBPACK_IMPORTED_MODULE_6__.buildRESTDescriptor)(module, metadata ?? {}, boundFetch, (relativeUrl, fetchOptions) => {\n                const finalUrl = new URL(relativeUrl, `https://${_common_js__WEBPACK_IMPORTED_MODULE_7__.API_URL}`);\n                finalUrl.host = _common_js__WEBPACK_IMPORTED_MODULE_7__.API_URL;\n                finalUrl.protocol = 'https';\n                return boundFetch(finalUrl.toString(), fetchOptions);\n            }, options);\n        }\n        else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(modules)) {\n            return Object.fromEntries(Object.entries(modules).map(([key, value]) => {\n                return [key, use(value, modules[_common_js__WEBPACK_IMPORTED_MODULE_7__.PUBLIC_METADATA_KEY])];\n            }));\n        }\n        else {\n            return modules;\n        }\n    };\n    const setHeaders = (headers) => {\n        for (const k in headers) {\n            _headers[k] = headers[k];\n        }\n    };\n    const wrappedModules = config.modules\n        ? use(config.modules)\n        : {};\n    return {\n        ...wrappedModules,\n        auth: authStrategy,\n        setHeaders,\n        use,\n        enableContext(contextType, opts = { elevated: false }) {\n            if (contextType === 'global') {\n                if (globalThis.__wix_context__ != null) {\n                    if (opts.elevated) {\n                        globalThis.__wix_context__.elevatedClient = this;\n                    }\n                    else {\n                        globalThis.__wix_context__.client = this;\n                    }\n                }\n                else {\n                    if (opts.elevated) {\n                        globalThis.__wix_context__ = { elevatedClient: this };\n                    }\n                    else {\n                        globalThis.__wix_context__ = { client: this };\n                    }\n                }\n            }\n            else {\n                if (opts.elevated) {\n                    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_8__.wixContext.elevatedClient = this;\n                }\n                else {\n                    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_8__.wixContext.client = this;\n                }\n            }\n        },\n        fetch: (relativeUrl, options) => {\n            const finalUrl = new URL(relativeUrl, `https://${_common_js__WEBPACK_IMPORTED_MODULE_7__.API_URL}`);\n            finalUrl.host = _common_js__WEBPACK_IMPORTED_MODULE_7__.API_URL;\n            finalUrl.protocol = 'https';\n            return boundFetch(finalUrl.toString(), options);\n        },\n        fetchWithAuth: async (urlOrRequest, requestInit) => {\n            if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {\n                return fetch(urlOrRequest, {\n                    ...requestInit,\n                    headers: {\n                        ...requestInit?.headers,\n                        ...(await boundGetAuthHeaders()).headers,\n                    },\n                });\n            }\n            else {\n                for (const [k, v] of Object.entries((await boundGetAuthHeaders()).headers)) {\n                    urlOrRequest.headers.set(k, v);\n                }\n                return fetch(urlOrRequest, requestInit);\n            }\n        },\n        async graphql(query, variables, opts = {\n            apiVersion: 'alpha',\n        }) {\n            const res = await boundFetch(`https://${_common_js__WEBPACK_IMPORTED_MODULE_7__.API_URL}/graphql/${opts.apiVersion}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ query, variables }),\n            });\n            if (res.status !== 200) {\n                throw new _fetch_error_js__WEBPACK_IMPORTED_MODULE_9__.FetchErrorResponse(`GraphQL request failed with status ${res.status}`, res);\n            }\n            const { data, errors } = await res.json();\n            return { data: data ?? {}, errors };\n        },\n        webhooks: eventHandlersClient,\n        servicePlugins: servicePluginsClient,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor-application/node_modules/@wix/sdk/build/wixClient.js?");

/***/ }),

/***/ "./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context-v2.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context-v2.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDefinition: () => (/* reexport safe */ _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__.EventDefinition),\n/* harmony export */   ServicePluginDefinition: () => (/* reexport safe */ _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__.ServicePluginDefinition),\n/* harmony export */   contextualizeEventDefinitionModuleV2: () => (/* binding */ contextualizeEventDefinitionModuleV2),\n/* harmony export */   contextualizeHostModuleV2: () => (/* binding */ contextualizeHostModuleV2),\n/* harmony export */   contextualizeRESTModuleV2: () => (/* binding */ contextualizeRESTModuleV2),\n/* harmony export */   contextualizeSerivcePluginModuleV2: () => (/* binding */ contextualizeSerivcePluginModuleV2)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context.js\");\n\n\n\nfunction contextualizeHostModuleV2(hostModule, props) {\n    return {\n        ...hostModule,\n        ...Object.fromEntries(props.map((prop) => [\n            prop,\n            (...args) => {\n                const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n                if (!context) {\n                    throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n                }\n                return context\n                    .initWixModules(hostModule)[prop].apply(undefined, args);\n            },\n        ])),\n    };\n}\nfunction contextualizeRESTModuleV2(restModule, elevated) {\n    return ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // @ts-expect-error - if there is no context, we want to behave like the original module\n            return restModule.apply(undefined, args);\n        }\n        return (context\n            .initWixModules(restModule, elevated)\n            // @ts-expect-error - we know the args here are meant to be passed to the initalized module\n            .apply(undefined, args));\n    });\n}\nfunction contextualizeEventDefinitionModuleV2(eventDefinition) {\n    const contextualMethod = ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // this line should throw, but this would be a breaking change for older SDK versions\n            // this is because in wixClient there's code that calls any function it detects and checks\n            // if it's an ambassador module (see isAmbassadorModule)\n            return () => { };\n        }\n        return context.initWixModules(eventDefinition).apply(undefined, args);\n    });\n    contextualMethod.__type = eventDefinition.__type;\n    contextualMethod.type = eventDefinition.type;\n    contextualMethod.isDomainEvent = eventDefinition.isDomainEvent;\n    contextualMethod.transformations = eventDefinition.transformations;\n    return contextualMethod;\n}\nfunction contextualizeSerivcePluginModuleV2(servicePlugin) {\n    const contextualMethod = ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // this line should throw, but this would be a breaking change for older SDK versions\n            // this is because in wixClient there's code that calls any function it detects and checks\n            // if it's an ambassador module (see isAmbassadorModule)\n            return () => { };\n        }\n        return context.initWixModules(servicePlugin).apply(undefined, args);\n    });\n    contextualMethod.__type = servicePlugin.__type;\n    contextualMethod.componentType = servicePlugin.componentType;\n    contextualMethod.methods = servicePlugin.methods;\n    return contextualMethod;\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context-v2.js?");

/***/ }),

/***/ "./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDefinition: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.EventDefinition),\n/* harmony export */   ServicePluginDefinition: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.ServicePluginDefinition),\n/* harmony export */   contextualizeEventDefinitionModule: () => (/* binding */ contextualizeEventDefinitionModule),\n/* harmony export */   contextualizeEventDefinitionModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeEventDefinitionModuleV2),\n/* harmony export */   contextualizeHostModule: () => (/* binding */ contextualizeHostModule),\n/* harmony export */   contextualizeHostModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeHostModuleV2),\n/* harmony export */   contextualizeRESTModule: () => (/* binding */ contextualizeRESTModule),\n/* harmony export */   contextualizeRESTModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeRESTModuleV2),\n/* harmony export */   contextualizeSerivcePluginModule: () => (/* binding */ contextualizeSerivcePluginModule),\n/* harmony export */   contextualizeSerivcePluginModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeSerivcePluginModuleV2),\n/* harmony export */   resolveContext: () => (/* binding */ resolveContext),\n/* harmony export */   runWithoutContext: () => (/* binding */ runWithoutContext)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk-context */ \"./node_modules/@wix/sdk-context/build/browser/index.mjs\");\n/* harmony import */ var _context_v2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context-v2.js */ \"./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context-v2.js\");\n\nfunction resolveContext() {\n    const oldContext = typeof $wixContext !== 'undefined' && $wixContext.initWixModules\n        ? $wixContext.initWixModules\n        : typeof globalThis.__wix_context__ !== 'undefined' &&\n            globalThis.__wix_context__.initWixModules\n            ? globalThis.__wix_context__.initWixModules\n            : undefined;\n    if (oldContext) {\n        return {\n            // @ts-expect-error\n            initWixModules(modules, elevated) {\n                return runWithoutContext(() => oldContext(modules, elevated));\n            },\n            fetchWithAuth() {\n                throw new Error('fetchWithAuth is not available in this context');\n            },\n            graphql() {\n                throw new Error('graphql is not available in this context');\n            },\n        };\n    }\n    const contextualClient = typeof $wixContext !== 'undefined'\n        ? $wixContext.client\n        : typeof _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client !== 'undefined'\n            ? _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client\n            : typeof globalThis.__wix_context__ !== 'undefined'\n                ? globalThis.__wix_context__.client\n                : undefined;\n    const elevatedClient = typeof $wixContext !== 'undefined'\n        ? $wixContext.elevatedClient\n        : typeof _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient !== 'undefined'\n            ? _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient\n            : typeof globalThis.__wix_context__ !== 'undefined'\n                ? globalThis.__wix_context__.elevatedClient\n                : undefined;\n    if (!contextualClient && !elevatedClient) {\n        return;\n    }\n    return {\n        initWixModules(wixModules, elevated) {\n            if (elevated) {\n                if (!elevatedClient) {\n                    throw new Error('An elevated client is required to use elevated modules. Make sure to initialize the Wix context with an elevated client before using elevated SDK modules');\n                }\n                return runWithoutContext(() => elevatedClient.use(wixModules));\n            }\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return runWithoutContext(() => contextualClient.use(wixModules));\n        },\n        fetchWithAuth: (urlOrRequest, requestInit) => {\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return contextualClient.fetchWithAuth(urlOrRequest, requestInit);\n        },\n        async graphql(query, variables, opts) {\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return contextualClient.graphql(query, variables, opts);\n        },\n    };\n}\nfunction contextualizeHostModule(hostModule, prop) {\n    return (...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(hostModule)[prop].apply(undefined, args);\n    };\n}\nfunction contextualizeRESTModule(restModule, expectedArgsLength) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context\n            .initWixModules(restModule, args[expectedArgsLength]?.suppressAuth ? true : false)\n            .apply(undefined, args);\n    });\n}\nfunction contextualizeEventDefinitionModule(eventDefinition) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(eventDefinition).apply(undefined, args);\n    });\n}\nfunction contextualizeSerivcePluginModule(servicePlugin) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(servicePlugin).apply(undefined, args);\n    });\n}\n\nfunction runWithoutContext(fn) {\n    const globalContext = globalThis.__wix_context__;\n    const moduleContext = {\n        client: _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client,\n        elevatedClient: _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient,\n    };\n    let closureContext;\n    globalThis.__wix_context__ = undefined;\n    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client = undefined;\n    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient = undefined;\n    if (typeof $wixContext !== 'undefined') {\n        closureContext = {\n            client: $wixContext?.client,\n            elevatedClient: $wixContext?.elevatedClient,\n        };\n        delete $wixContext.client;\n        delete $wixContext.elevatedClient;\n    }\n    try {\n        return fn();\n    }\n    finally {\n        globalThis.__wix_context__ = globalContext;\n        _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client = moduleContext.client;\n        _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient = moduleContext.elevatedClient;\n        if (typeof $wixContext !== 'undefined') {\n            $wixContext.client = closureContext.client;\n            $wixContext.elevatedClient = closureContext.elevatedClient;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context.js?");

/***/ }),

/***/ "./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/host-modules.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/host-modules.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHostModule: () => (/* binding */ createHostModule)\n/* harmony export */ });\n/* harmony import */ var _context_v2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context-v2.js */ \"./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/context-v2.js\");\n\nfunction createHostModule(hostModuleAPI) {\n    return (0,_context_v2_js__WEBPACK_IMPORTED_MODULE_0__.contextualizeHostModuleV2)({\n        __type: 'host',\n        create: (host) => Object.entries(hostModuleAPI).reduce((acc, [key, fn]) => ({\n            ...acc,\n            [key]: fn(host),\n        }), {}),\n    }, Object.keys(hostModuleAPI));\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/editor/node_modules/@wix/sdk-runtime/build/host-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   EditorPlatformInternalErrorCode: () => (/* binding */ EditorPlatformInternalErrorCode),\n/* harmony export */   createEditorPlatformInternalError: () => (/* binding */ createEditorPlatformInternalError),\n/* harmony export */   createErrorBuilder: () => (/* binding */ createErrorBuilder)\n/* harmony export */ });\nclass BaseError extends Error {\n  state = {};\n  displayName;\n  prefix;\n  errorMessage;\n  parent;\n  messages = [];\n  code;\n  constructor(_message, _code, _prefix) {\n    const message = _message ? ` ${_message}` : \"\";\n    const displayName = `[${_prefix}]#${_code}`;\n    super(`${displayName}.${message}`);\n    this.displayName = displayName;\n    this.errorMessage = _message;\n    this.prefix = _prefix;\n    this.code = _code;\n    this.name = displayName;\n    Object.defineProperty(this, \"message\", {\n      get: () => {\n        return this.getDisplayMessage();\n      }\n    });\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BaseError);\n    }\n  }\n  get parentError() {\n    const parent = this.parent;\n    if (!parent) {\n      return null;\n    }\n    if (this.parent instanceof BaseError) {\n      return this.parent;\n    }\n    const displayName = parent.name ?? \"[Unknown Error]\";\n    return {\n      getBreadcrumbs() {\n        return [displayName];\n      },\n      getMessage() {\n        return [displayName, parent.message ?? \"unknown error message\"].join(\n          \"\\n\"\n        );\n      }\n    };\n  }\n  /**\n   * Returns formatted error message with breadcrumbs\n   */\n  getDisplayMessage() {\n    const breadcrumbs = this.parentError ? this.getBreadcrumbs() : [];\n    return [breadcrumbs.join(\" -> \"), this.getMessage()].filter((x) => x.trim().length).join(\"\\n\");\n  }\n  /**\n   * Returns formatted error message\n   */\n  getMessage() {\n    const state = Object.entries(this.state).reduce((acc, [key, value]) => {\n      if (value) {\n        acc.push(` \\u2013 ${key}: ${value}`);\n      }\n      return acc;\n    }, []).join(\"\\n\");\n    const messages = this.messages.reduce((acc, _messages) => {\n      acc.push(` - ${_messages.join(\" \")}`);\n      return acc;\n    }, []).join(\"\\n\");\n    const parentError = this.parentError;\n    const parentErrorMessage = parentError ? [\"\", parentError.getMessage(), \"\"].join(\"\\n\") : \"\";\n    const thrownErrorMessage = this.errorMessage ? `${this.displayName}: ${this.errorMessage}` : this.displayName;\n    return [parentErrorMessage, thrownErrorMessage, state, messages].filter((x) => x.trim().length).join(\"\\n\");\n  }\n  getBreadcrumbs() {\n    const parentError = this.parentError;\n    if (!parentError) {\n      return [this.displayName];\n    }\n    return [...parentError.getBreadcrumbs(), this.displayName];\n  }\n  withParentError(e) {\n    this.parent = e;\n    return this;\n  }\n  withMessage(...messages) {\n    this.messages.push(messages);\n    return this;\n  }\n}\nfunction createErrorBuilder(factory) {\n  return function throwException(code, message = \"\") {\n    const instance = new factory(message, code);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(instance, throwException);\n    }\n    return instance;\n  };\n}\n\nvar EditorPlatformInternalErrorCode = /* @__PURE__ */ ((EditorPlatformInternalErrorCode2) => {\n  EditorPlatformInternalErrorCode2[\"UnexpectedError\"] = \"UnexpectedError\";\n  return EditorPlatformInternalErrorCode2;\n})(EditorPlatformInternalErrorCode || {});\nclass EditorPlatformInternalError extends BaseError {\n  state = {};\n  constructor(message, code) {\n    super(message, code, \"Editor Platform Internal Error\");\n  }\n  withHost(host) {\n    this.state = { ...this.state, host };\n    return this;\n  }\n}\nconst createEditorPlatformInternalError = createErrorBuilder(EditorPlatformInternalError);\n\n\n//# sourceMappingURL=index.mjs.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/public-editor-platform-errors/dist/esm/index.mjs?");

/***/ }),

/***/ "./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DMEventsBridge: () => (/* binding */ DMEventsBridge),\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),\n/* harmony export */   PlatformAppEvent: () => (/* binding */ PlatformAppEvent),\n/* harmony export */   PlatformAppEventEmitter: () => (/* binding */ PlatformAppEventEmitter),\n/* harmony export */   PlatformLifecycleEvent: () => (/* binding */ PlatformLifecycleEvent),\n/* harmony export */   PlatformPrivateEvent: () => (/* binding */ PlatformPrivateEvent),\n/* harmony export */   PlatformPrivateEventEmitter: () => (/* binding */ PlatformPrivateEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/public-editor-platform-interfaces */ \"./node_modules/@wix/public-editor-platform-interfaces/dist/index.js\");\n\n\nclass EventEmitter {\n  static biEvents = {\n    PLATFORM_WORKER_SPAWN: 123,\n    PLATFORM_APP_RUNNER_INIT_APP_API: 124,\n    PLATFORM_APP_RUNNER_RUN_APP: 125,\n    PLATFORM_APP_RUNNER_REMOVE_APP: 126,\n    PLATFORM_WORKER_APP_BUNDLE_LOAD: 127,\n    PLATFORM_WORKER_APP_BUNDLE_EXECUTE: 128,\n    PLATFORM_IFRAME_INIT: 129,\n    PLATFORM_APP_API_INIT: 130,\n    PLATFORM_APP_API_GET: 131\n  };\n  static EventSteps = {\n    Start: \"start\",\n    End: \"end\",\n    Error: \"error\"\n  };\n  uid = 0;\n  callbacks = /* @__PURE__ */ new Map();\n  inTransaction = false;\n  isSilent = false;\n  queue = [];\n  silent(isSilent = true) {\n    this.isSilent = isSilent;\n  }\n  startTransaction() {\n    this.inTransaction = true;\n  }\n  commit() {\n    this.inTransaction = false;\n    const queue = this.queue;\n    this.queue = [];\n    if (!this.isSilent) {\n      queue.forEach((event) => {\n        this.notify(event);\n      });\n    }\n  }\n  notify(event) {\n    if (this.isSilent) {\n      return;\n    }\n    if (this.inTransaction) {\n      this.queue.push(event);\n    } else {\n      this.callbacks.forEach((callback) => {\n        callback(event);\n      });\n    }\n  }\n  subscribe(callback) {\n    const uid = this.uid++;\n    this.callbacks.set(uid, callback);\n    return () => {\n      this.callbacks.delete(uid);\n    };\n  }\n  notifyWithStep(event, step) {\n    this.notify({\n      ...event,\n      meta: {\n        ...event.meta,\n        step\n      }\n    });\n  }\n  async withEvent(event, cb) {\n    let result = cb();\n    if (result && result.hasOwnProperty(\"then\")) {\n      try {\n        this.notifyWithStep(event, EventEmitter.EventSteps.Start);\n        result = await result;\n        this.notifyWithStep(event, EventEmitter.EventSteps.End);\n        return result;\n      } catch (e) {\n        this.notifyWithStep(\n          {\n            ...event,\n            meta: {\n              ...event.meta,\n              error: e\n            }\n          },\n          EventEmitter.EventSteps.Error\n        );\n        throw e;\n      }\n    } else {\n      this.notify(event);\n      return result;\n    }\n  }\n}\n\nvar PlatformPrivateEvent = /* @__PURE__ */ ((PlatformPrivateEvent2) => {\n  PlatformPrivateEvent2[\"WorkerSpawn\"] = \"WorkerSpawn\";\n  PlatformPrivateEvent2[\"HostEvent\"] = \"HostEvent\";\n  PlatformPrivateEvent2[\"ApplicationsSpecsReceived\"] = \"ApplicationsSpecsReceived\";\n  PlatformPrivateEvent2[\"InitApplicationApi\"] = \"InitApplicationApi\";\n  PlatformPrivateEvent2[\"RunApplication\"] = \"RunApplication\";\n  PlatformPrivateEvent2[\"getApplicationApi\"] = \"getApplicationApi\";\n  PlatformPrivateEvent2[\"IframeInit\"] = \"IframeInit\";\n  return PlatformPrivateEvent2;\n})(PlatformPrivateEvent || {});\nvar PlatformLifecycleEvent = /* @__PURE__ */ ((PlatformLifecycleEvent2) => {\n  PlatformLifecycleEvent2[\"EditorReady\"] = \"EditorReady\";\n  return PlatformLifecycleEvent2;\n})(PlatformLifecycleEvent || {});\nclass PlatformPrivateEventFactories {\n  createWorkerSpawnEvent({\n    url,\n    workerId,\n    strategy\n  }) {\n    return {\n      type: \"WorkerSpawn\" /* WorkerSpawn */,\n      payload: {\n        url\n      },\n      meta: {\n        bi: {\n          evid: PlatformPrivateEventEmitter.biEvents.PLATFORM_WORKER_SPAWN,\n          workerId,\n          strategy\n        }\n      }\n    };\n  }\n  createRunApplicationEvent(app) {\n    return {\n      type: \"RunApplication\" /* RunApplication */,\n      payload: {\n        appDefinitionId: app.appDefinitionId\n      },\n      meta: {\n        bi: {\n          appType: app.type,\n          appDefId: app.appDefinitionId,\n          evid: PlatformPrivateEventEmitter.biEvents.PLATFORM_APP_RUNNER_RUN_APP\n        }\n      }\n    };\n  }\n  createGetApplicationApiEvent(targetAppDefId, scope) {\n    return {\n      type: \"getApplicationApi\" /* getApplicationApi */,\n      payload: {},\n      meta: {\n        bi: {\n          targetAppDefId,\n          scope,\n          evid: PlatformPrivateEventEmitter.biEvents.PLATFORM_APP_API_GET\n        }\n      }\n    };\n  }\n  createInitApplicationApiEvent(appDefinitionId) {\n    return {\n      type: \"InitApplicationApi\" /* InitApplicationApi */,\n      payload: {\n        appDefinitionId\n      },\n      meta: {\n        bi: {\n          appDefId: appDefinitionId,\n          evid: PlatformPrivateEventEmitter.biEvents.PLATFORM_APP_API_INIT\n        }\n      }\n    };\n  }\n  createIframeInitEvent(frameUrl, iframeId) {\n    return {\n      type: \"IframeInit\" /* IframeInit */,\n      payload: {},\n      meta: {\n        bi: {\n          frameUrl,\n          iframeId,\n          evid: PlatformPrivateEventEmitter.biEvents.PLATFORM_IFRAME_INIT\n        }\n      }\n    };\n  }\n}\nclass PlatformPrivateEventEmitter extends EventEmitter {\n  factories = new PlatformPrivateEventFactories();\n  notify(event) {\n    super.notify(event);\n  }\n}\n\nvar PlatformAppEvent = /* @__PURE__ */ ((PlatformAppEvent2) => {\n  PlatformAppEvent2[\"ApplicationInit\"] = \"ApplicationInit\";\n  PlatformAppEvent2[\"ApplicationExecute\"] = \"ApplicationExecute\";\n  PlatformAppEvent2[\"ApplicationRemoved\"] = \"ApplicationRemoved\";\n  PlatformAppEvent2[\"ApplicationLoad\"] = \"ApplicationLoad\";\n  PlatformAppEvent2[\"ApplicationApiInit\"] = \"ApplicationApiInit\";\n  PlatformAppEvent2[\"CustomEvent\"] = \"CustomEvent\";\n  PlatformAppEvent2[\"HostEvent\"] = \"HostEvent\";\n  PlatformAppEvent2[\"EditorReady\"] = \"EditorReady\";\n  return PlatformAppEvent2;\n})(PlatformAppEvent || {});\nclass PlatformAppEventsFactories {\n  createApplicationRemovedEvent(appDefinitionId) {\n    return {\n      type: \"ApplicationRemoved\" /* ApplicationRemoved */,\n      payload: {\n        appDefinitionId\n      },\n      meta: {\n        bi: {\n          evid: PlatformAppEventEmitter.biEvents.PLATFORM_WORKER_SPAWN,\n          appDefId: appDefinitionId\n        }\n      }\n    };\n  }\n  createApplicationLoadEvent(app, url) {\n    return {\n      type: \"ApplicationLoad\" /* ApplicationLoad */,\n      payload: {\n        appDefinitionId: app.appDefinitionId,\n        url\n      },\n      meta: {\n        bi: {\n          evid: PlatformAppEventEmitter.biEvents.PLATFORM_WORKER_APP_BUNDLE_LOAD,\n          appDefId: app.appDefinitionId,\n          appType: app.appType,\n          bundleUrl: url\n        }\n      }\n    };\n  }\n  createApplicationExecuteEvent(app, url) {\n    return {\n      type: \"ApplicationExecute\" /* ApplicationExecute */,\n      payload: {\n        appDefinitionId: app.appDefinitionId,\n        url\n      },\n      meta: {\n        bi: {\n          evid: PlatformAppEventEmitter.biEvents.PLATFORM_WORKER_APP_BUNDLE_EXECUTE,\n          appDefId: app.appDefinitionId,\n          appType: app.appType,\n          bundleUrl: url\n        }\n      }\n    };\n  }\n  createApplicationApiInitEvent(appDefinitionId, scope) {\n    return {\n      type: \"ApplicationApiInit\" /* ApplicationApiInit */,\n      payload: { appDefinitionId },\n      meta: {\n        bi: {\n          evid: PlatformAppEventEmitter.biEvents.PLATFORM_APP_API_INIT,\n          appDefId: appDefinitionId,\n          scope\n        }\n      }\n    };\n  }\n}\nclass PlatformAppEventEmitter extends EventEmitter {\n  factories = new PlatformAppEventsFactories();\n}\n\nclass DMEventsBridge {\n  constructor(events) {\n    this.events = events;\n  }\n  static allowedEvents = [\n    _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__.EventType.componentSelectionChanged,\n    _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__.EventType.appInstalled,\n    _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__.EventType.appUpdateCompleted,\n    _wix_public_editor_platform_interfaces__WEBPACK_IMPORTED_MODULE_0__.EventType.removeAppCompleted\n  ];\n  mapToPlatformHostEvent(event) {\n    if (typeof event === \"string\") {\n      try {\n        event = JSON.parse(event);\n      } catch (e) {\n      }\n    }\n    return {\n      type: PlatformPrivateEvent.HostEvent,\n      payload: {\n        type: event.args.eventType,\n        ...event.args.eventPayload\n      },\n      meta: {\n        appDefinitionId: event.appDefinitionId ?? null,\n        intent: event.intent\n      }\n    };\n  }\n  /**\n   * Notify by event from Worker Manager (platform infrastructure)\n   */\n  notify(_event) {\n    const event = this.mapToPlatformHostEvent(_event);\n    if (DMEventsBridge.allowedEvents.includes(event.payload.type)) {\n      this.events.notify(event);\n    }\n  }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/public-editor-platform-events/dist/esm/index.mjs?");

/***/ }),

/***/ "./node_modules/@wix/sdk-context/build/browser/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@wix/sdk-context/build/browser/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wixContext: () => (/* binding */ wixContext)\n/* harmony export */ });\n// src/index.ts\nvar wixContext = {};\n\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk-context/build/browser/index.mjs?");

/***/ }),

/***/ "./node_modules/@wix/sdk-types/build/browser/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@wix/sdk-types/build/browser/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDefinition: () => (/* binding */ EventDefinition),\n/* harmony export */   SERVICE_PLUGIN_ERROR_TYPE: () => (/* binding */ SERVICE_PLUGIN_ERROR_TYPE),\n/* harmony export */   ServicePluginDefinition: () => (/* binding */ ServicePluginDefinition)\n/* harmony export */ });\n// src/event-handlers-modules.ts\nfunction EventDefinition(type, isDomainEvent = false, transformations = (x) => x) {\n  return () => ({\n    __type: \"event-definition\",\n    type,\n    isDomainEvent,\n    transformations\n  });\n}\n\n// src/service-plugins.ts\nfunction ServicePluginDefinition(componentType, methods) {\n  return {\n    __type: \"service-plugin-definition\",\n    componentType,\n    methods\n  };\n}\nvar SERVICE_PLUGIN_ERROR_TYPE = \"wix_spi_error\";\n\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk-types/build/browser/index.mjs?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/ambassador-modules.js":
/*!***********************************************************!*\
  !*** ./node_modules/@wix/sdk/build/ambassador-modules.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAmbassadorModule: () => (/* binding */ isAmbassadorModule),\n/* harmony export */   toHTTPModule: () => (/* binding */ toHTTPModule)\n/* harmony export */ });\nconst parseMethod = (method) => {\n    switch (method) {\n        case 'get':\n        case 'GET':\n            return 'GET';\n        case 'post':\n        case 'POST':\n            return 'POST';\n        case 'put':\n        case 'PUT':\n            return 'PUT';\n        case 'delete':\n        case 'DELETE':\n            return 'DELETE';\n        case 'patch':\n        case 'PATCH':\n            return 'PATCH';\n        case 'head':\n        case 'HEAD':\n            return 'HEAD';\n        case 'options':\n        case 'OPTIONS':\n            return 'OPTIONS';\n        default:\n            throw new Error(`Unknown method: ${method}`);\n    }\n};\nconst toHTTPModule = (factory) => (httpClient) => async (payload) => {\n    let requestOptions;\n    const HTTPFactory = (context) => {\n        requestOptions = factory(payload)(context);\n        if (requestOptions.url === undefined) {\n            throw new Error('Url was not successfully created for this request, please reach out to support channels for assistance.');\n        }\n        const { method, url, params } = requestOptions;\n        return {\n            ...requestOptions,\n            method: parseMethod(method),\n            url,\n            data: requestOptions.data,\n            params,\n        };\n    };\n    try {\n        const response = await httpClient.request(HTTPFactory);\n        if (requestOptions === undefined) {\n            throw new Error('Request options were not created for this request, please reach out to support channels for assistance.');\n        }\n        const transformations = Array.isArray(requestOptions.transformResponse)\n            ? requestOptions.transformResponse\n            : [requestOptions.transformResponse];\n        /**\n         * Based on Axios implementation:\n         * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/lib/core/transformData.js#L22\n         */\n        let data = response.data;\n        transformations.forEach((transform) => {\n            if (transform) {\n                data = transform(response.data, response.headers);\n            }\n        });\n        return data;\n    }\n    catch (e) {\n        if (typeof e === 'object' &&\n            e !== null &&\n            'response' in e &&\n            typeof e.response === 'object' &&\n            e.response !== null &&\n            'data' in e.response) {\n            throw e.response.data;\n        }\n        throw e;\n    }\n};\n/*\n * Because of issues with tree-shaking, we cant really put static parameter on module.\n * We still have check for __isAmbassador for backward compatibility\n */\nconst isAmbassadorModule = (module) => {\n    if (module.__isAmbassador) {\n        return true;\n    }\n    const fn = module();\n    return Boolean(fn.__isAmbassador);\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/ambassador-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/bi/biHeaderGenerator.js":
/*!*************************************************************!*\
  !*** ./node_modules/@wix/sdk/build/bi/biHeaderGenerator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WixBIHeaderName: () => (/* binding */ WixBIHeaderName),\n/* harmony export */   biHeaderGenerator: () => (/* binding */ biHeaderGenerator)\n/* harmony export */ });\nconst WixBIHeaderName = 'x-wix-bi-gateway';\nfunction biHeaderGenerator(apiMetadata, publicMetadata) {\n    return {\n        [WixBIHeaderName]: objectToKeyValue({\n            environment: 'js-sdk',\n            'package-name': apiMetadata.packageName ?? publicMetadata?.PACKAGE_NAME,\n            'method-fqn': apiMetadata.methodFqn,\n            entity: apiMetadata.entityFqdn,\n        }),\n    };\n}\nfunction objectToKeyValue(input) {\n    return Object.entries(input)\n        .filter(([_, value]) => Boolean(value))\n        .map(([key, value]) => `${key}=${value}`)\n        .join(',');\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/bi/biHeaderGenerator.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/common.js":
/*!***********************************************!*\
  !*** ./node_modules/@wix/sdk/build/common.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_API_URL: () => (/* binding */ DEFAULT_API_URL),\n/* harmony export */   FORCE_WRITE_API_URLS: () => (/* binding */ FORCE_WRITE_API_URLS),\n/* harmony export */   PUBLIC_METADATA_KEY: () => (/* binding */ PUBLIC_METADATA_KEY)\n/* harmony export */ });\nconst PUBLIC_METADATA_KEY = '__metadata';\nconst DEFAULT_API_URL = 'www.wixapis.com';\nconst FORCE_WRITE_API_URLS = ['/ecom/v1/carts/current'];\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/common.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/event-handlers-modules.js":
/*!***************************************************************!*\
  !*** ./node_modules/@wix/sdk/build/event-handlers-modules.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildEventDefinition: () => (/* binding */ buildEventDefinition),\n/* harmony export */   eventHandlersModules: () => (/* binding */ eventHandlersModules),\n/* harmony export */   isEventHandlerModule: () => (/* binding */ isEventHandlerModule)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var _nanoevents_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nanoevents.js */ \"./node_modules/@wix/sdk/build/nanoevents.js\");\n\n\nconst isEventHandlerModule = (val) => val.__type === 'event-definition';\nfunction buildEventDefinition(eventDefinition, registerHandler) {\n    return (handler) => {\n        registerHandler(eventDefinition, handler);\n    };\n}\nfunction runHandler(eventDefinition, handler, payload, baseEventMetadata) {\n    let envelope;\n    if (eventDefinition.isDomainEvent) {\n        const domainEventPayload = payload;\n        const { deletedEvent, actionEvent, createdEvent, updatedEvent, ...domainEventMetadata } = domainEventPayload;\n        const metadata = {\n            ...baseEventMetadata,\n            ...domainEventMetadata,\n        };\n        if (deletedEvent) {\n            if (deletedEvent?.deletedEntity) {\n                envelope = {\n                    entity: deletedEvent?.deletedEntity,\n                    metadata,\n                };\n            }\n            else {\n                envelope = { metadata };\n            }\n        }\n        else if (actionEvent) {\n            envelope = {\n                data: actionEvent.body,\n                metadata,\n            };\n        }\n        else {\n            envelope = {\n                entity: createdEvent?.entity ?? updatedEvent?.currentEntity,\n                metadata,\n            };\n        }\n    }\n    else {\n        envelope = {\n            data: payload,\n            metadata: baseEventMetadata,\n        };\n    }\n    const transformFromRESTFn = eventDefinition.transformations ?? ((x) => x);\n    return handler(transformFromRESTFn(envelope));\n}\nfunction eventHandlersModules(authStrategy) {\n    const eventHandlers = new Map();\n    const webhooksEmitter = (0,_nanoevents_js__WEBPACK_IMPORTED_MODULE_0__.createNanoEvents)();\n    const client = {\n        ...webhooksEmitter,\n        getRegisteredEvents: () => eventHandlers,\n        async process(jwt, opts = {\n            expectedEvents: [],\n        }) {\n            const { eventType, identity, instanceId, payload } = await this.parseJWT(jwt);\n            const allExpectedEvents = [\n                ...opts.expectedEvents,\n                ...Array.from(eventHandlers.keys()).map((type) => ({ type })),\n            ];\n            if (allExpectedEvents.length > 0 &&\n                !allExpectedEvents.some(({ type }) => type === eventType)) {\n                throw new Error(`Unexpected event type: ${eventType}. Expected one of: ${allExpectedEvents\n                    .map((x) => x.type)\n                    .join(', ')}`);\n            }\n            const handlers = eventHandlers.get(eventType) ?? [];\n            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, payload, {\n                instanceId,\n                identity,\n            })));\n            return {\n                instanceId,\n                eventType,\n                payload,\n                identity,\n            };\n        },\n        async processRequest(request, opts) {\n            const body = await request.text();\n            return this.process(body, opts);\n        },\n        async parseJWT(jwt) {\n            if (!authStrategy.decodeJWT) {\n                throw new Error('decodeJWT is not supported by the authentication strategy');\n            }\n            const { decoded, valid } = await authStrategy.decodeJWT(jwt);\n            if (!valid) {\n                throw new Error('JWT is not valid');\n            }\n            if (typeof decoded.data !== 'string') {\n                throw new Error(`Unexpected type of JWT data: expected string, got ${typeof decoded.data}`);\n            }\n            const parsedDecoded = JSON.parse(decoded.data);\n            const eventType = parsedDecoded.eventType;\n            const instanceId = parsedDecoded.instanceId;\n            const identity = parsedDecoded.identity\n                ? JSON.parse(parsedDecoded.identity)\n                : undefined;\n            const payload = JSON.parse(parsedDecoded.data);\n            return {\n                instanceId,\n                eventType,\n                payload,\n                identity,\n            };\n        },\n        async parseRequest(request) {\n            const jwt = await request.text();\n            return this.parseJWT(jwt);\n        },\n        async executeHandlers(event) {\n            const allExpectedEvents = Array.from(eventHandlers.keys()).map((type) => ({ type }));\n            if (allExpectedEvents.length > 0 &&\n                !allExpectedEvents.some(({ type }) => type === event.eventType)) {\n                throw new Error(`Unexpected event type: ${event.eventType}. Expected one of: ${allExpectedEvents\n                    .map((x) => x.type)\n                    .join(', ')}`);\n            }\n            const handlers = eventHandlers.get(event.eventType) ?? [];\n            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, event.payload, {\n                instanceId: event.instanceId,\n                identity: event.identity,\n            })));\n        },\n        apps: {\n            AppInstalled: (0,_wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__.EventDefinition)('AppInstalled')(),\n            AppRemoved: (0,_wix_sdk_types__WEBPACK_IMPORTED_MODULE_1__.EventDefinition)('AppRemoved')(),\n        },\n    };\n    return {\n        initModule(eventDefinition) {\n            return (handler) => {\n                const handlers = eventHandlers.get(eventDefinition.type) ?? [];\n                handlers.push({ eventDefinition, handler });\n                eventHandlers.set(eventDefinition.type, handlers);\n                webhooksEmitter.emit('registered', eventDefinition);\n            };\n        },\n        client,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/event-handlers-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/fetch-error.js":
/*!****************************************************!*\
  !*** ./node_modules/@wix/sdk/build/fetch-error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchErrorResponse: () => (/* binding */ FetchErrorResponse)\n/* harmony export */ });\nclass FetchErrorResponse extends Error {\n    message;\n    response;\n    constructor(message, response) {\n        super(message);\n        this.message = message;\n        this.response = response;\n    }\n    async details() {\n        const dataError = await this.response.json();\n        return errorBuilder(this.response.status, dataError?.message, dataError?.details, {\n            requestId: this.response.headers.get('X-Wix-Request-Id'),\n            details: dataError,\n        });\n    }\n}\nconst errorBuilder = (code, description, details, data) => {\n    return {\n        details: {\n            ...(!details?.validationError && {\n                applicationError: {\n                    description,\n                    code,\n                    data,\n                },\n            }),\n            ...details,\n        },\n        message: description,\n    };\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/fetch-error.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/helpers.js":
/*!************************************************!*\
  !*** ./node_modules/@wix/sdk/build/helpers.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultContentHeader: () => (/* binding */ getDefaultContentHeader),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   parsePublicKeyIfEncoded: () => (/* binding */ parsePublicKeyIfEncoded)\n/* harmony export */ });\n// we follow a simplified version of the axios convention\n// https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/defaults/index.js#L65\nconst getDefaultContentHeader = (options) => {\n    if (options?.method &&\n        ['post', 'put', 'patch'].includes(options.method.toLocaleLowerCase()) &&\n        options.body) {\n        return { 'Content-Type': 'application/json' };\n    }\n    return {};\n};\nconst isObject = (val) => val && typeof val === 'object' && !Array.isArray(val);\nfunction parsePublicKeyIfEncoded(publicKey) {\n    if (publicKey.includes('\\n') || publicKey.includes('\\r')) {\n        // publicKey is multi-line string, can be used as is\n        return publicKey.trim();\n    }\n    else {\n        // publicKey is base64 encoded\n        return typeof atob !== 'undefined'\n            ? atob(publicKey)\n            : Buffer.from(publicKey, 'base64').toString('utf-8');\n    }\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/helpers.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/host-modules.js":
/*!*****************************************************!*\
  !*** ./node_modules/@wix/sdk/build/host-modules.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildHostModule: () => (/* binding */ buildHostModule),\n/* harmony export */   isHostModule: () => (/* binding */ isHostModule)\n/* harmony export */ });\nconst isHostModule = (val) => val.__type === 'host';\nfunction buildHostModule(val, host) {\n    return val.create(host);\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/host-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/nanoevents.js":
/*!***************************************************!*\
  !*** ./node_modules/@wix/sdk/build/nanoevents.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNanoEvents: () => (/* binding */ createNanoEvents)\n/* harmony export */ });\n// Inlined from https://github.com/ai/nanoevents/blob/main/index.js\n/**\n * Create event emitter.\n *\n * ```js\n * import { createNanoEvents } from 'nanoevents'\n *\n * class Ticker {\n * constructor() {\n * this.emitter = createNanoEvents()\n * }\n * on(...args) {\n * return this.emitter.on(...args)\n * }\n * tick() {\n * this.emitter.emit('tick')\n * }\n * }\n * ```\n * @returns Event emitter.\n */\nfunction createNanoEvents() {\n    return {\n        emit(event, ...args) {\n            for (let i = 0, callbacks = this.events[event] || [], length = callbacks.length; i < length; i++) {\n                callbacks[i](...args);\n            }\n        },\n        events: {},\n        on(event, cb) {\n            (this.events[event] ||= []).push(cb);\n            return () => {\n                this.events[event] = this.events[event]?.filter((i) => cb !== i);\n            };\n        },\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/nanoevents.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/rest-modules.js":
/*!*****************************************************!*\
  !*** ./node_modules/@wix/sdk/build/rest-modules.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildRESTDescriptor: () => (/* binding */ buildRESTDescriptor)\n/* harmony export */ });\n/* harmony import */ var _bi_biHeaderGenerator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bi/biHeaderGenerator.js */ \"./node_modules/@wix/sdk/build/bi/biHeaderGenerator.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@wix/sdk/build/common.js\");\n/* harmony import */ var _wix_sdk_runtime_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk-runtime/context */ \"./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js\");\n\n\n\nfunction buildRESTDescriptor(origFunc, publicMetadata, boundFetch, wixAPIFetch, options) {\n    return (0,_wix_sdk_runtime_context__WEBPACK_IMPORTED_MODULE_0__.runWithoutContext)(() => origFunc({\n        request: async (factory) => {\n            const requestOptions = factory({\n                host: options?.HTTPHost || _common_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_API_URL,\n            });\n            let request = requestOptions;\n            if (request.method === 'GET' &&\n                request.fallback?.length &&\n                request.params.toString().length > 4000) {\n                request = requestOptions.fallback[0];\n            }\n            const domain = options?.HTTPHost ?? _common_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_API_URL;\n            let url = `https://${domain}${request.url}`;\n            if (request.params && request.params.toString()) {\n                url += `?${request.params.toString()}`;\n            }\n            try {\n                const biHeader = (0,_bi_biHeaderGenerator_js__WEBPACK_IMPORTED_MODULE_2__.biHeaderGenerator)(requestOptions, publicMetadata);\n                const res = await boundFetch(url, {\n                    method: request.method,\n                    ...(request.data && {\n                        body: JSON.stringify(request.data),\n                    }),\n                    headers: {\n                        ...biHeader,\n                    },\n                });\n                if (res.status !== 200) {\n                    let dataError = null;\n                    try {\n                        dataError = await res.json();\n                    }\n                    catch (e) {\n                        //\n                    }\n                    throw errorBuilder(res.status, dataError?.message, dataError?.details, {\n                        requestId: res.headers.get('X-Wix-Request-Id'),\n                        details: dataError,\n                    });\n                }\n                const data = await res.json();\n                return {\n                    data,\n                    headers: res.headers,\n                    status: res.status,\n                    statusText: res.statusText,\n                };\n            }\n            catch (e) {\n                if (e.message?.includes('fetch is not defined')) {\n                    console.error('Node.js v18+ is required');\n                }\n                throw e;\n            }\n        },\n        fetchWithAuth: boundFetch,\n        wixAPIFetch,\n    }));\n}\nconst errorBuilder = (code, description, details, data) => {\n    return {\n        response: {\n            data: {\n                details: {\n                    ...(!details?.validationError && {\n                        applicationError: {\n                            description,\n                            code,\n                            data,\n                        },\n                    }),\n                    ...details,\n                },\n                message: description,\n            },\n            status: code,\n        },\n    };\n};\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/rest-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/service-plugin-modules.js":
/*!***************************************************************!*\
  !*** ./node_modules/@wix/sdk/build/service-plugin-modules.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isServicePluginModule: () => (/* binding */ isServicePluginModule),\n/* harmony export */   servicePluginsModules: () => (/* binding */ servicePluginsModules)\n/* harmony export */ });\n/* harmony import */ var _nanoevents_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nanoevents.js */ \"./node_modules/@wix/sdk/build/nanoevents.js\");\n\nconst isServicePluginModule = (val) => val.__type === 'service-plugin-definition';\nfunction servicePluginsModules(authStrategy) {\n    const servicePluginsImplementations = new Map();\n    const servicePluginsEmitter = (0,_nanoevents_js__WEBPACK_IMPORTED_MODULE_0__.createNanoEvents)();\n    const client = {\n        ...servicePluginsEmitter,\n        getRegisteredServicePlugins: () => servicePluginsImplementations,\n        async parseJWT(jwt) {\n            if (!authStrategy.decodeJWT) {\n                throw new Error('decodeJWT is not supported by the authentication strategy');\n            }\n            const { decoded, valid } = await authStrategy.decodeJWT(jwt, true);\n            if (!valid) {\n                throw new Error('JWT is not valid');\n            }\n            if (typeof decoded.data !== 'object' ||\n                decoded.data === null ||\n                !('metadata' in decoded.data) ||\n                typeof decoded.data.metadata !== 'object' ||\n                decoded.data.metadata === null ||\n                !('appExtensionType' in decoded.data.metadata) ||\n                typeof decoded.data.metadata.appExtensionType !== 'string') {\n                throw new Error('Unexpected JWT data: expected object with metadata.appExtensionType string');\n            }\n            return decoded.data;\n        },\n        async process(request) {\n            const servicePluginRequest = await this.parseJWT(request.body);\n            return this.executeHandler(servicePluginRequest, request.url);\n        },\n        async parseRequest(request) {\n            const body = await request.text();\n            return this.parseJWT(body);\n        },\n        async processRequest(request) {\n            const url = request.url;\n            const body = await request.text();\n            const implMethodResult = await this.process({ url, body });\n            return Response.json(implMethodResult);\n        },\n        async executeHandler(servicePluginRequest, url) {\n            const componentType = servicePluginRequest.metadata.appExtensionType.toLowerCase();\n            const implementations = servicePluginsImplementations.get(componentType) ?? [];\n            if (implementations.length === 0) {\n                throw new Error(`No service plugin implementations found for component type ${componentType}`);\n            }\n            else if (implementations.length > 1) {\n                throw new Error(`Multiple service plugin implementations found for component type ${componentType}. This is currently not supported`);\n            }\n            const { implementation: impl, servicePluginDefinition } = implementations[0];\n            const method = servicePluginDefinition.methods.find((m) => url.endsWith(m.primaryHttpMappingPath));\n            if (!method) {\n                throw new Error('Unexpect request: request url did not match any method: ' + url);\n            }\n            const implMethod = impl[method.name];\n            if (!implMethod) {\n                throw new Error(`Got request for service plugin method ${method.name} but no implementation was provided. Available methods: ${Object.keys(impl).join(', ')}`);\n            }\n            return method.transformations.toREST(await implMethod(method.transformations.fromREST(servicePluginRequest)));\n        },\n    };\n    return {\n        initModule(servicePluginDefinition) {\n            return (implementation) => {\n                const implementations = servicePluginsImplementations.get(servicePluginDefinition.componentType.toLowerCase()) ?? [];\n                implementations.push({ servicePluginDefinition, implementation });\n                servicePluginsImplementations.set(servicePluginDefinition.componentType.toLowerCase(), implementations);\n                servicePluginsEmitter.emit('registered', servicePluginDefinition);\n            };\n        },\n        client,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/service-plugin-modules.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/build/wixClient.js":
/*!**************************************************!*\
  !*** ./node_modules/@wix/sdk/build/wixClient.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @wix/sdk-context */ \"./node_modules/@wix/sdk-context/build/browser/index.mjs\");\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var _ambassador_modules_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ambassador-modules.js */ \"./node_modules/@wix/sdk/build/ambassador-modules.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@wix/sdk/build/common.js\");\n/* harmony import */ var _fetch_error_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./fetch-error.js */ \"./node_modules/@wix/sdk/build/fetch-error.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@wix/sdk/build/helpers.js\");\n/* harmony import */ var _host_modules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./host-modules.js */ \"./node_modules/@wix/sdk/build/host-modules.js\");\n/* harmony import */ var _rest_modules_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rest-modules.js */ \"./node_modules/@wix/sdk/build/rest-modules.js\");\n/* harmony import */ var _event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-handlers-modules.js */ \"./node_modules/@wix/sdk/build/event-handlers-modules.js\");\n/* harmony import */ var _service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service-plugin-modules.js */ \"./node_modules/@wix/sdk/build/service-plugin-modules.js\");\n/* harmony import */ var _wix_sdk_runtime_context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @wix/sdk-runtime/context */ \"./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction createClient(config) {\n    const _headers = config.headers || { Authorization: '' };\n    const authStrategy = config.auth ||\n        {\n            getAuthHeaders: (_) => Promise.resolve({ headers: {} }),\n        };\n    const boundGetAuthHeaders = authStrategy.getAuthHeaders.bind(undefined, config.host);\n    authStrategy.getAuthHeaders = boundGetAuthHeaders;\n    const { client: servicePluginsClient, initModule: initServicePluginModule } = (0,_service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__.servicePluginsModules)(authStrategy);\n    const { client: eventHandlersClient, initModule: initEventHandlerModule } = (0,_event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__.eventHandlersModules)(authStrategy);\n    const boundFetch = async (url, options) => {\n        const authHeaders = await boundGetAuthHeaders();\n        const defaultContentTypeHeader = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultContentHeader)(options);\n        return fetch(url, {\n            ...options,\n            headers: {\n                ...defaultContentTypeHeader,\n                ..._headers,\n                ...authHeaders?.headers,\n                ...options?.headers,\n            },\n        });\n    };\n    // This is typed as `any` because when trying to properly type it as defined\n    // on the WixClient, typescript starts failing with `Type instantiation is\n    // excessively deep and possibly infinite.`\n    const use = (modules, metadata) => {\n        if ((0,_event_handlers_modules_js__WEBPACK_IMPORTED_MODULE_1__.isEventHandlerModule)(modules)) {\n            return initEventHandlerModule(modules);\n        }\n        else if ((0,_service_plugin_modules_js__WEBPACK_IMPORTED_MODULE_0__.isServicePluginModule)(modules)) {\n            return initServicePluginModule(modules);\n        }\n        else if ((0,_host_modules_js__WEBPACK_IMPORTED_MODULE_3__.isHostModule)(modules) && config.host) {\n            return (0,_host_modules_js__WEBPACK_IMPORTED_MODULE_3__.buildHostModule)(modules, config.host);\n        }\n        else if (typeof modules === 'function') {\n            // The generated namespaces all have the error classes on them and\n            // a class is also a function, so we need to explicitly ignore these\n            // error classes using a static field that exists on them.\n            if ('__type' in modules && modules.__type === _wix_sdk_types__WEBPACK_IMPORTED_MODULE_4__.SERVICE_PLUGIN_ERROR_TYPE) {\n                return modules;\n            }\n            const apiBaseUrl = config.host?.apiBaseUrl ?? _common_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_API_URL;\n            return (0,_rest_modules_js__WEBPACK_IMPORTED_MODULE_6__.buildRESTDescriptor)((0,_wix_sdk_runtime_context__WEBPACK_IMPORTED_MODULE_7__.runWithoutContext)(() => (0,_ambassador_modules_js__WEBPACK_IMPORTED_MODULE_8__.isAmbassadorModule)(modules))\n                ? (0,_ambassador_modules_js__WEBPACK_IMPORTED_MODULE_8__.toHTTPModule)(modules)\n                : modules, metadata ?? {}, boundFetch, (relativeUrl, fetchOptions) => {\n                const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);\n                finalUrl.host = apiBaseUrl;\n                finalUrl.protocol = 'https';\n                return boundFetch(finalUrl.toString(), fetchOptions);\n            }, { HTTPHost: apiBaseUrl });\n        }\n        else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(modules)) {\n            return Object.fromEntries(Object.entries(modules).map(([key, value]) => {\n                return [key, use(value, modules[_common_js__WEBPACK_IMPORTED_MODULE_5__.PUBLIC_METADATA_KEY])];\n            }));\n        }\n        else {\n            return modules;\n        }\n    };\n    const setHeaders = (headers) => {\n        for (const k in headers) {\n            _headers[k] = headers[k];\n        }\n    };\n    const wrappedModules = config.modules\n        ? use(config.modules)\n        : {};\n    return {\n        ...wrappedModules,\n        auth: authStrategy,\n        setHeaders,\n        use,\n        enableContext(contextType, opts = { elevated: false }) {\n            if (contextType === 'global') {\n                if (globalThis.__wix_context__ != null) {\n                    if (opts.elevated) {\n                        globalThis.__wix_context__.elevatedClient = this;\n                    }\n                    else {\n                        globalThis.__wix_context__.client = this;\n                    }\n                }\n                else {\n                    if (opts.elevated) {\n                        globalThis.__wix_context__ = { elevatedClient: this };\n                    }\n                    else {\n                        globalThis.__wix_context__ = { client: this };\n                    }\n                }\n            }\n            else {\n                if (opts.elevated) {\n                    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_9__.wixContext.elevatedClient = this;\n                }\n                else {\n                    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_9__.wixContext.client = this;\n                }\n            }\n        },\n        fetch: (relativeUrl, options) => {\n            const apiBaseUrl = config.host?.apiBaseUrl ?? _common_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_API_URL;\n            const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);\n            finalUrl.host = apiBaseUrl;\n            finalUrl.protocol = 'https';\n            return boundFetch(finalUrl.toString(), options);\n        },\n        fetchWithAuth: async (urlOrRequest, requestInit) => {\n            if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {\n                return fetch(urlOrRequest, {\n                    ...requestInit,\n                    headers: {\n                        ...requestInit?.headers,\n                        ...(await boundGetAuthHeaders()).headers,\n                    },\n                });\n            }\n            else {\n                for (const [k, v] of Object.entries((await boundGetAuthHeaders()).headers)) {\n                    urlOrRequest.headers.set(k, v);\n                }\n                return fetch(urlOrRequest, requestInit);\n            }\n        },\n        async graphql(query, variables, opts = {\n            apiVersion: 'alpha',\n        }) {\n            const apiBaseUrl = config?.host?.apiBaseUrl ?? _common_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_API_URL;\n            const res = await boundFetch(`https://${apiBaseUrl}/graphql/${opts.apiVersion}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ query, variables }),\n            });\n            if (res.status !== 200) {\n                throw new _fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchErrorResponse(`GraphQL request failed with status ${res.status}`, res);\n            }\n            const { data, errors } = await res.json();\n            return { data: data ?? {}, errors };\n        },\n        webhooks: eventHandlersClient,\n        servicePlugins: servicePluginsClient,\n    };\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/build/wixClient.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context-v2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context-v2.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDefinition: () => (/* reexport safe */ _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__.EventDefinition),\n/* harmony export */   ServicePluginDefinition: () => (/* reexport safe */ _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__.ServicePluginDefinition),\n/* harmony export */   contextualizeEventDefinitionModuleV2: () => (/* binding */ contextualizeEventDefinitionModuleV2),\n/* harmony export */   contextualizeHostModuleV2: () => (/* binding */ contextualizeHostModuleV2),\n/* harmony export */   contextualizeRESTModuleV2: () => (/* binding */ contextualizeRESTModuleV2),\n/* harmony export */   contextualizeSerivcePluginModuleV2: () => (/* binding */ contextualizeSerivcePluginModuleV2)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk-types */ \"./node_modules/@wix/sdk-types/build/browser/index.mjs\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js\");\n\n\n\nfunction contextualizeHostModuleV2(hostModule, props) {\n    return {\n        ...hostModule,\n        ...Object.fromEntries(props.map((prop) => [\n            prop,\n            (...args) => {\n                const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n                if (!context) {\n                    throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n                }\n                return context\n                    .initWixModules(hostModule)[prop].apply(undefined, args);\n            },\n        ])),\n    };\n}\nfunction contextualizeRESTModuleV2(restModule, elevated) {\n    return ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // @ts-expect-error - if there is no context, we want to behave like the original module\n            return restModule.apply(undefined, args);\n        }\n        return (context\n            .initWixModules(restModule, elevated)\n            // @ts-expect-error - we know the args here are meant to be passed to the initalized module\n            .apply(undefined, args));\n    });\n}\nfunction contextualizeEventDefinitionModuleV2(eventDefinition) {\n    const contextualMethod = ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // this line should throw, but this would be a breaking change for older SDK versions\n            // this is because in wixClient there's code that calls any function it detects and checks\n            // if it's an ambassador module (see isAmbassadorModule)\n            return () => { };\n        }\n        return context.initWixModules(eventDefinition).apply(undefined, args);\n    });\n    contextualMethod.__type = eventDefinition.__type;\n    contextualMethod.type = eventDefinition.type;\n    contextualMethod.isDomainEvent = eventDefinition.isDomainEvent;\n    contextualMethod.transformations = eventDefinition.transformations;\n    return contextualMethod;\n}\nfunction contextualizeSerivcePluginModuleV2(servicePlugin) {\n    const contextualMethod = ((...args) => {\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.resolveContext)();\n        if (!context) {\n            // this line should throw, but this would be a breaking change for older SDK versions\n            // this is because in wixClient there's code that calls any function it detects and checks\n            // if it's an ambassador module (see isAmbassadorModule)\n            return () => { };\n        }\n        return context.initWixModules(servicePlugin).apply(undefined, args);\n    });\n    contextualMethod.__type = servicePlugin.__type;\n    contextualMethod.componentType = servicePlugin.componentType;\n    contextualMethod.methods = servicePlugin.methods;\n    return contextualMethod;\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context-v2.js?");

/***/ }),

/***/ "./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDefinition: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.EventDefinition),\n/* harmony export */   ServicePluginDefinition: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.ServicePluginDefinition),\n/* harmony export */   contextualizeEventDefinitionModule: () => (/* binding */ contextualizeEventDefinitionModule),\n/* harmony export */   contextualizeEventDefinitionModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeEventDefinitionModuleV2),\n/* harmony export */   contextualizeHostModule: () => (/* binding */ contextualizeHostModule),\n/* harmony export */   contextualizeHostModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeHostModuleV2),\n/* harmony export */   contextualizeRESTModule: () => (/* binding */ contextualizeRESTModule),\n/* harmony export */   contextualizeRESTModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeRESTModuleV2),\n/* harmony export */   contextualizeSerivcePluginModule: () => (/* binding */ contextualizeSerivcePluginModule),\n/* harmony export */   contextualizeSerivcePluginModuleV2: () => (/* reexport safe */ _context_v2_js__WEBPACK_IMPORTED_MODULE_1__.contextualizeSerivcePluginModuleV2),\n/* harmony export */   resolveContext: () => (/* binding */ resolveContext),\n/* harmony export */   runWithoutContext: () => (/* binding */ runWithoutContext)\n/* harmony export */ });\n/* harmony import */ var _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wix/sdk-context */ \"./node_modules/@wix/sdk-context/build/browser/index.mjs\");\n/* harmony import */ var _context_v2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context-v2.js */ \"./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context-v2.js\");\n\nfunction resolveContext() {\n    const oldContext = typeof $wixContext !== 'undefined' && $wixContext.initWixModules\n        ? $wixContext.initWixModules\n        : typeof globalThis.__wix_context__ !== 'undefined' &&\n            globalThis.__wix_context__.initWixModules\n            ? globalThis.__wix_context__.initWixModules\n            : undefined;\n    if (oldContext) {\n        return {\n            // @ts-expect-error\n            initWixModules(modules, elevated) {\n                return runWithoutContext(() => oldContext(modules, elevated));\n            },\n            fetchWithAuth() {\n                throw new Error('fetchWithAuth is not available in this context');\n            },\n            graphql() {\n                throw new Error('graphql is not available in this context');\n            },\n        };\n    }\n    const contextualClient = typeof $wixContext !== 'undefined'\n        ? $wixContext.client\n        : typeof _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client !== 'undefined'\n            ? _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client\n            : typeof globalThis.__wix_context__ !== 'undefined'\n                ? globalThis.__wix_context__.client\n                : undefined;\n    const elevatedClient = typeof $wixContext !== 'undefined'\n        ? $wixContext.elevatedClient\n        : typeof _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient !== 'undefined'\n            ? _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient\n            : typeof globalThis.__wix_context__ !== 'undefined'\n                ? globalThis.__wix_context__.elevatedClient\n                : undefined;\n    if (!contextualClient && !elevatedClient) {\n        return;\n    }\n    return {\n        initWixModules(wixModules, elevated) {\n            if (elevated) {\n                if (!elevatedClient) {\n                    throw new Error('An elevated client is required to use elevated modules. Make sure to initialize the Wix context with an elevated client before using elevated SDK modules');\n                }\n                return runWithoutContext(() => elevatedClient.use(wixModules));\n            }\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return runWithoutContext(() => contextualClient.use(wixModules));\n        },\n        fetchWithAuth: (urlOrRequest, requestInit) => {\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return contextualClient.fetchWithAuth(urlOrRequest, requestInit);\n        },\n        async graphql(query, variables, opts) {\n            if (!contextualClient) {\n                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n            }\n            return contextualClient.graphql(query, variables, opts);\n        },\n    };\n}\nfunction contextualizeHostModule(hostModule, prop) {\n    return (...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(hostModule)[prop].apply(undefined, args);\n    };\n}\nfunction contextualizeRESTModule(restModule, expectedArgsLength) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context\n            .initWixModules(restModule, args[expectedArgsLength]?.suppressAuth ? true : false)\n            .apply(undefined, args);\n    });\n}\nfunction contextualizeEventDefinitionModule(eventDefinition) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(eventDefinition).apply(undefined, args);\n    });\n}\nfunction contextualizeSerivcePluginModule(servicePlugin) {\n    return ((...args) => {\n        const context = resolveContext();\n        if (!context) {\n            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');\n        }\n        return context.initWixModules(servicePlugin).apply(undefined, args);\n    });\n}\n\nfunction runWithoutContext(fn) {\n    const globalContext = globalThis.__wix_context__;\n    const moduleContext = {\n        client: _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client,\n        elevatedClient: _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient,\n    };\n    let closureContext;\n    globalThis.__wix_context__ = undefined;\n    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client = undefined;\n    _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient = undefined;\n    if (typeof $wixContext !== 'undefined') {\n        closureContext = {\n            client: $wixContext?.client,\n            elevatedClient: $wixContext?.elevatedClient,\n        };\n        delete $wixContext.client;\n        delete $wixContext.elevatedClient;\n    }\n    try {\n        return fn();\n    }\n    finally {\n        globalThis.__wix_context__ = globalContext;\n        _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.client = moduleContext.client;\n        _wix_sdk_context__WEBPACK_IMPORTED_MODULE_0__.wixContext.elevatedClient = moduleContext.elevatedClient;\n        if (typeof $wixContext !== 'undefined') {\n            $wixContext.client = closureContext.client;\n            $wixContext.elevatedClient = closureContext.elevatedClient;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://test-1/./node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js?");

/***/ }),

/***/ "./node_modules/nanoevents/index.js":
/*!******************************************!*\
  !*** ./node_modules/nanoevents/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNanoEvents: () => (/* binding */ createNanoEvents)\n/* harmony export */ });\nlet createNanoEvents = () => ({\n  emit(event, ...args) {\n    for (\n      let i = 0,\n        callbacks = this.events[event] || [],\n        length = callbacks.length;\n      i < length;\n      i++\n    ) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    ;(this.events[event] ||= []).push(cb)\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n\n\n//# sourceURL=webpack://test-1/./node_modules/nanoevents/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/panel.js");
/******/ 	
/******/ })()
;